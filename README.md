> ℹ️ GitHub Actions полностью удалены из репозитория: автоматические пайплайны недоступны. Интеграционные проверки выполняются только локально согласно инструкции из [`docs/local-setup.md`](docs/local-setup.md).

> ℹ️ Легаси-контейнер `payments` удалён из Docker Compose; архивный код сохранён в [`backend/payments`](backend/payments/README.md) и запускается только вручную при необходимости.

**Быстрая навигация:** [План поставки](docs/delivery-plan.md), [Архитектура](docs/architecture.md#1-общая-структура-сервисов), [Технологический стек](docs/tech-stack.md), [API](docs/api/README.md), [Локальная настройка](docs/local-setup.md), [Тестовые данные](docs/testing-data.md), [Бэкапы](backups/README.md)

## Быстрый старт

```bash
./scripts/bootstrap-local.sh
```

Сценарий последовательно выполняет ключевые шаги локальной подготовки, управляя инфраструктурой через Docker Compose, и печатает агрегированную таблицу статусов. Перед каждым запуском Docker Compose скрипт импортирует переменные из актуального `.env`, поэтому вложенные ссылки вида `VAR=${OTHER_VAR}` раскрываются автоматически. После ручного изменения `.env` перезапустите `./scripts/bootstrap-local.sh`, чтобы новые значения оказались в окружении контейнеров. Для запуска прикладных сервисов прямо на хосте вызовите `./scripts/bootstrap-local.sh --with-backend --skip-backend` (или установите `BOOTSTRAP_WITH_BACKEND=true` вместе с `BOOTSTRAP_SKIP_BACKEND=true`) — bootstrap пропустит compose-профиль backend, освободит порты и после миграций запустит helper `scripts/start-backend.sh`. Если требуется управлять сервисами вручную или собирать расширенные логи, воспользуйтесь [пошаговым сценарием](docs/local-setup.md#пошаговый-запуск-микросервисов) и запускайте нужные процессы через `scripts/start-backend.sh --service ...`, чтобы включить только необходимые процессы.

Сценарий включает следующие этапы:

1. создание отсутствующих `.env` через `scripts/sync-env.sh --non-interactive` (существующие файлы пропускаются; для обновления значений запустите `scripts/sync-env.sh --non-interactive=overwrite` либо проверьте их вручную);
2. запуск инфраструктуры `docker compose --env-file .env up -d` в каталоге `infra/`;
3. ожидание готовности инфраструктурных контейнеров (`docker compose wait` либо резервный цикл с проверкой healthcheck);
4. автоматическую настройку RabbitMQ (`infra/rabbitmq/bootstrap.sh`) — обмены и очереди появляются до старта прикладных сервисов;
5. миграции CRM/Auth через `scripts/migrate-local.sh`, пока инфраструктура готова, а backend-профиль ещё не поднят;
6. smoke-проверку `BACKUP_*`: при пустых `BACKUP_S3_*` скрипт сообщает о переходе на `DummyStorage` (штатный режим локальной разработки) и продолжает выполнение, а при частично заполненной конфигурации S3 — останавливается с подсказкой;
7. дополнительную smoke-проверку, которая удостоверяется, что контейнер `backup` действительно запущен в режиме `DummyStorage`, когда `BACKUP_S3_*` пусты;
8. старт профильных API `docker compose --env-file .env --profile backend up -d` (Gateway, Auth, CRM, Documents; поддерживается флаг `--skip-backend` или переменная `BOOTSTRAP_SKIP_BACKEND=true` для ограничения только инфраструктурой);
9. ожидание готовности backend-профиля (`docker compose --profile backend wait` с fallback на ручной опрос `/health`; при необходимости можно передать `--skip-backend-wait` или `BOOTSTRAP_SKIP_BACKEND_WAIT=true`, чтобы пропустить ожидание и перейти к следующим шагам);
10. опциональный запуск локальных backend-процессов через `scripts/start-backend.sh` (активируется комбинацией `--with-backend --skip-backend` или переменными `BOOTSTRAP_WITH_BACKEND=true` и `BOOTSTRAP_SKIP_BACKEND=true`, PID, журналы сервисов и файл запуска по умолчанию сохраняются в `.local/run/backend`; путь можно переопределить опцией `--log-file` или переменной `START_BACKEND_LOG_FILE`). Для запуска только части сервисов используйте аргумент `--service NAME` у `scripts/start-backend.sh` (можно перечислять через запятую и повторять флаг, например `scripts/start-backend.sh --service gateway` или `scripts/start-backend.sh --service auth,crm-api --service gateway`). Например, чтобы ограничиться Gateway и CRM API, выполните `scripts/start-backend.sh --service gateway,crm-api`.
11. загрузку seed-данных, если существует `scripts/load-seeds.sh` (скрипт работает только с SQL-файлами Postgres и больше не запускает легаси Tasks);
12. smoke-проверку окружения `scripts/check-local-infra.sh` (PostgreSQL, Redis, Consul, RabbitMQ UI, Reports) и REST/SSE эндпоинтов backend-профиля (Gateway, Auth, CRM, Documents).

Если требуется один сценарий с дополнительными опциями (`--skip-backend`, `--skip-backend-wait`, `--with-backend`, `--log-file PATH`), используйте `./scripts/dev-up.sh` — он остаётся обёрткой вокруг bootstrap-скрипта, переиспользует те же шаги и добавляет централизованное логирование. При запуске `./scripts/dev-up.sh --skip-backend` соответствующий профиль автоматически пропускается в bootstrap, поэтому контейнеры не стартуют ни на одном этапе. Флаг `--skip-backend-wait` (или переменная `DEV_UP_SKIP_BACKEND_WAIT=true`) передаёт в bootstrap решение пропустить ожидание готовности compose-профиля backend, если требуется перейти к ручной проверке. Флаг `--with-backend` (или переменная `DEV_UP_WITH_BACKEND=true`) следует комбинировать с `--skip-backend`, чтобы docker compose не удерживал порты перед запуском `scripts/start-backend.sh`; при нарушении условия helper предупреждает о дублирующихся процессах. Журнал работы `dev-up` пишется через `tee` в `.local/logs/dev-up.log` (переменная `DEV_UP_LOG_FILE` либо опция `--log-file` позволяют задать другой путь; при повторных запусках запись продолжается в конец файла, относительные пути интерпретируются относительно корня репозитория). Автоматическое открытие браузера в сценарии не реализовано — при необходимости откройте интерфейс вручную. Ручные вызовы `scripts/start-backend.sh` (включая `scripts/start-backend.sh --service ...`) и `scripts/stop-backend.sh` остаются совместимыми с автоматическими сценариями — bootstrap и `dev-up` используют те же helpers и корректно обрабатывают уже запущенные процессы.

Для остановки вспомогательных процессов, поднятых `scripts/start-backend.sh`, предусмотрен зеркальный `scripts/stop-backend.sh`. Скрипт читает PID-файлы из `.local/run/backend`, отправляет `SIGTERM` (с fallback на `SIGKILL`) и удаляет служебные файлы. Опция `--service <имя>` позволяет завершить только выбранные процессы, не затрагивая остальные, что удобно при частичном ручном запуске. При необходимости используйте `--log-file PATH` (или переменную `START_BACKEND_LOG_FILE`) для указания журнала запуска и `--clean-logs`, чтобы удалить накопленные логи; по умолчанию они остаются в `.local/run/backend` и пополняются при каждом старте helper-а. Для расследований инцидентов сохраняйте `start-backend.log` и файлы из `.local/run/backend/logs/` вместе с журналами bootstrap (`.local/logs/bootstrap/...`) — эти артефакты помогают воспроизвести последовательность действий.

> ℹ️ Все вызовы Docker Compose в скриптах теперь включают `--env-file .env`. Поддерживайте корневой `.env` синхронизированным с `env.example` и актуальными секретами: `scripts/sync-env.sh --non-interactive` добавляет только отсутствующие файлы, поэтому для обновления существующих используйте `scripts/sync-env.sh --non-interactive=overwrite` или сверяйте значения вручную.
>
Обязательные зависимости: Docker с Compose V2, Python 3 (`python3`), Poetry и JDK 17+ (для Gradle wrapper в `backend/auth`). Скрипты bootstrap и `infra/rabbitmq/bootstrap.sh` автоматически ищут интерпретатор в порядке `python3`, `python`, `python3.12`, `python3.11`, `python3.10`, `python3.9`, `python3.8`, `py -3`, `py -3.12`, `py -3.11`, `py -3.10`, `py -3.9`, поэтому одинаково работают в Git Bash (Windows) и на Linux/macOS — достаточно, чтобы одна из этих команд была доступна в `PATH`. Отсутствие CLI `psql`, `redis-cli`, `curl` приводит только к предупреждениям — bootstrap продолжится, а для соответствующих шагов можно использовать `docker compose exec` или альтернативные инструменты. Скрипт автоматически выдаёт предупреждение о пропущенных шагах и сохраняет логи неудачных этапов во временной директории.

1. Общее представление
CRM предназначена для небольшой команды страховых агентов, которые ведут клиентов по долгосрочным страховым сделкам. Система концентрирует данные о клиентах, сделках, полисах, платежах и связанных документах, распределяет задачи между пользователями и обеспечивает контроль по ключевым событиям. Архитектурный черновик выделяет целевые сервисы (Gateway, Auth, CRM/Deals, Documents, Reports, Backup) и встроенные модули CRM для задач и уведомлений (включая SSE-поток `notifications`).【F:docs/architecture.md†L7-L33】 Платёжный контур входит в модуль CRM/Deals: бизнес-логика, REST API и публикация доменных событий реализованы в FastAPI-приложении CRM, а обмен выполняется через общую БД и RabbitMQ. Каталог [`backend/payments`](backend/payments) сохранён только как архивная версия прежнего standalone-сервиса и служит справочным источником для анализа наследия. Состав первой поставки и критерии готовности описаны в документе [`docs/delivery-plan.md`](docs/delivery-plan.md). Подробные спецификации REST/SSE интерфейсов находятся в каталоге [`docs/api`](docs/api/README.md), а форматы интеграционных событий зафиксированы в [`docs/integration-events.md`](docs/integration-events.md).

### Текущее состояние репозитория
В репозитории уже лежат рабочие backend-сервисы первой волны: **Gateway/BFF** (NestJS + pnpm), **Auth** (Spring Boot + Gradle) и **CRM/Deals** (FastAPI + Celery) со встроенными модулями задач, уведомлений и платежей, которые предоставляют REST/SSE API и публикуют события от имени CRM.【F:docs/api/tasks.md†L1-L39】【F:docs/api/notifications.md†L1-L33】 Каркас сервиса **Documents** и инфраструктурного набора **Backup** подготовлен вместе с миграциями и инструкциями; прикладная логика развивается согласно `docs/delivery-plan.md`. Каталог **Reports** содержит рабочий каркас FastAPI-сервиса с подключением к PostgreSQL (см. [`backend/reports/README.md`](backend/reports/README.md)). Центрального сервиса аудита нет: прикладные системы ведут собственные журналы, а витрины Reports агрегируют события для ретроспективного анализа. Gateway обслуживает внутренних клиентов (CRM UI через BFF), Telegram-бота и внешние интеграции, поэтому первичные точки взаимодействия описаны в `docs/architecture.md` и `docs/api`. Детали по окружению и API остаются в `docs/tech-stack.md`, `docs/api` и `env.example`. Каталоги [`backend/tasks`](backend/tasks/README.md) и [`backend/notifications`](backend/notifications/README.md) сохранены как легаси-код для анализа миграции и не используются в текущем контуре; активный платежный модуль поставляется внутри [`backend/crm`](backend/crm/README.md), а каталог [`backend/payments`](backend/payments) содержит только архивные материалы standalone-сервиса.

**Технологический стек и базовые архитектурные принципы** собраны в документе [`docs/tech-stack.md`](docs/tech-stack.md), который служит основой для детальных спецификаций сервисов и инфраструктуры.

#### Статус удаления мультитенантности
- Backend CRM, API и инфраструктура очищены от `tenant_id` и готовы к миграции; завершены сопутствующие обновления (см. [детальный план и статус](docs/REMOVAL-MULTI-TENANCY.md)).
- Тесты CRM (`backend/crm/tests`), настольное приложение (`desktop_app/*.py`) и SQL-сиды (`backups/postgres/seeds/seed_20240715_crm.sql`) актуализированы под однотенантную модель, остаточных упоминаний `tenant_id` не осталось.

### Структура репозитория
- [`docs/local-setup.md`](docs/local-setup.md) — карта сервисов с портами и ссылками на инструкции запуска.
- [`docs/testing-data.md`](docs/testing-data.md) — стандартный набор тестовых данных и процедура загрузки seed-миграций.
- Backend:
  - [`backend/gateway/README.md`](backend/gateway/README.md) — запуск BFF/Gateway.【F:backend/gateway/README.md†L1-L34】
  - [`backend/auth/README.md`](backend/auth/README.md) — конфигурация Auth и миграции Liquibase.【F:backend/auth/README.md†L1-L30】
  - [`backend/crm/README.md`](backend/crm/README.md) — инструкции для CRM/Deals и Celery.【F:backend/crm/README.md†L1-L32】
- [`backend/payments/README.md`](backend/payments/README.md) — архивная документация standalone-сервиса Payments; актуальный платёжный модуль поставляется внутри [`backend/crm`](backend/crm/README.md) и именно CRM публикует API и события.
  - [`backend/documents/README.md`](backend/documents/README.md) — NestJS-сервис для серверного файлового хранилища и BullMQ.【F:backend/documents/README.md†L1-L30】
  - Легаси каталоги [`backend/tasks`](backend/tasks/README.md) и [`backend/notifications`](backend/notifications/README.md) оставлены для истории миграции; действующие API задач и уведомлений описаны в CRM (`docs/api/tasks.md`, `docs/api/notifications.md`).【F:docs/api/tasks.md†L1-L39】【F:docs/api/notifications.md†L1-L33】
  - [`backend/telegram-bot/README.md`](backend/telegram-bot/README.md) — FastAPI + aiogram сервис Telegram-бота с вебхуком и интеграциями CRM/Auth/Notifications.
  - [`backend/reports/README.md`](backend/reports/README.md) — FastAPI-сервис Reports и инструкции по подключению к CRM.【F:backend/reports/README.md†L1-L47】
- Backups: [`backups/README.md`](backups/README.md) — скрипты и артефакты резервного копирования.【F:backups/README.md†L1-L8】
## Запуск окружения разработки

Подробная инструкция с альтернативными ручными шагами описана в [`docs/local-setup.md`](docs/local-setup.md). Используйте её, если нужно выполнить подготовку выборочно или воспроизвести отдельный этап. Перед стартом приложений дополнительно можно выполнить smoke-check `./scripts/check-local-infra.sh`, чтобы убедиться в доступности PostgreSQL, Redis, Consul, RabbitMQ Management UI и заполненности переменных `BACKUP_*` внутри контейнера резервного копирования.
Для быстрого старта выполните `./scripts/bootstrap-local.sh`: скрипт проверит наличие `.env`, поднимет инфраструктуру через `docker compose --env-file .env`, настроит RabbitMQ и применит миграции CRM/Auth. Подробности и требования перечислены в разделе [`docs/local-setup.md`](docs/local-setup.md). Если требуется ручной контроль каждого шага, воспользуйтесь fallback-инструкцией из того же документа. Перед стартом приложений рекомендуем запустить smoke-check `./scripts/check-local-infra.sh` (при отсутствии `psql`/`redis-cli`/`curl` можно использовать `docker compose exec` и аналоги), чтобы автоматически убедиться в доступности PostgreSQL, Redis, Consul и RabbitMQ Management UI.

Для ручной проверки переменных резервного копирования можно выполнить:

```bash
cd infra/
docker compose --env-file ../.env exec backup sh -c 'env | grep "^BACKUP_"'
```

Команда выводит значения всех `BACKUP_*`; пустые строки допустимы для локального режима — сервис `backup` в этом случае использует `DummyStorage` и складывает артефакты в `BACKUP_ARTIFACTS_DIR`.

2. Пользовательские роли
Система использует одноуровневую модель доступа с тремя ролевыми типами. Если у роли есть доступ к сущности, то она может просматривать и изменять данные в рамках закреплённых за ней клиентов и сделок; дополнительных уровней «только чтение» или «расширенный доступ» нет для операционных ролей.

- **Главный админ** — управляет пользователями, системными справочниками и имеет полный доступ ко всем сущностям для администрирования и аудита.
- **Продавец (агент)** — инициирует сделки, ведёт коммуникацию с клиентом, управляет журналом сделки, полисами, документами и расходами в своих сделках.
- **Исполнитель** — готовит расчёты, оформляет полисы и поддерживает документооборот в сделках, где назначен, с правом вносить изменения в назначенных сущностях.

3. Основные сущности
Клиент. Физическое или юридическое лицо. Атрибуты: реквизиты, контакты, одно или несколько контактных лиц, сегмент, статус (потенциальный, активный, неактивный). У клиента может быть множество сделок.

Сделка. Объединяет страховые потребности клиента по одному объекту или группе объектов. Содержит:

описание объекта страхования (например, автомобиль, парк ТС, ипотечное имущество);

участников (ведущий пользователь, дополнительные участники);

журнал текстовых заметок (пробег авто, остаток долга и т.п.);

расчёты по страховым компаниям;

набор полисов;

привязанные задачи и документы (структура папок описана в разделе 5).

планируемую дату следующего обзора (`nextReviewAt`), которая управляет сортировкой карточек сделки и напоминаниями.

Расчёт. Результат обращения к страховой компании. Атрибуты: компания, программа, условия, тарифы, дата расчёта, комментарии, файлы. Хранится история изменений.

Полис. Конкретный договор страхования (обычно на 1 год). Атрибуты: номер, страхователь, программа, период действия, страховая сумма, премия, статус (черновик, действует, ожидает продления, закрыт). Привязан к сделке и клиенту.

Платёж. Финансовая запись, жёстко привязанная к одному полису. Для полиса допускается множество записей — так фиксируются частичные оплаты, доначисления комиссии и последующие выплаты. Базовая таблица `crm.payments` хранит реквизиты операции: агрегированную сумму, валюту, фактическую дату (`actual_date`), комментарий, пользователя, подтвердившего запись, а также предрасчитанные агрегаты по связанным позициям (`incomes_total`, `expenses_total`, `net_total`). Распределение на несколько полисов не допускается. Если операция затрагивает разные полисы, создаются отдельные записи.

Структура доходов и расходов хранится отдельными позициями: доходные строки (`crm.payment_incomes`) фиксируют премии клиента и поступления комиссии, расходные (`crm.payment_expenses`) — скидки клиенту, выплаты коллегам и другие удержания. Все позиции ссылаются на базовый платёж, наследуют его метаданные и суммируются в агрегаты `incomes_total`/`expenses_total`/`net_total`, что позволяет совмещать доходы и расходы внутри одной записи без деления по направлению. Для корректировок создаются дополнительные строки с отрицательными суммами, статусных полей нет — записи отражают факт и редактируются вручную либо импортом CSV.

Документ. Файл в серверном хранилище. Типы: расчёт, заявление, договор, полис, акт, чек, переписка. Метаданные: владельцы (сделка/полис/платёж), дата загрузки, автор, заметки. Генерация документов не требуется — только хранение и структурирование.

Задача. Назначение для пользователя. Атрибуты: связанная сделка/полис/платёж, обязательное текстовое описание, срок, приоритет, напоминания, статус выполнения.

4. Ответственность сервисов

Развёрнутые обязанности и взаимодействия приводятся в документе [«Архитектурный обзор»](docs/architecture.md#2-взаимодействия-и-потоки-данных); ниже — краткое резюме доменов.
Gateway/BFF. Общая точка входа для клиентских приложений (CRM UI, Telegram-бот, внешние интеграции), управление сессиями, маршрутизация запросов к сервисам, агрегация данных (подробнее см. [`backend/gateway/README.md`](backend/gateway/README.md)).

Auth. Управление пользователями, ролями и доступами к сделкам/документам (включая разграничение каталогов хранилища); подробности и сценарии миграций — в [`backend/auth/README.md`](backend/auth/README.md).

CRM/Deals. Владеет клиентами, сделками, расчётами, полисами, журналами сделок, задачами, уведомлениями о ключевых событиях; бизнес-потоки и запуск описаны в [`backend/crm/README.md`](backend/crm/README.md).

Платежи (модуль CRM/Deals). Учёт всех финансовых движений по полисам, включая множественные записи на один полис, детализацию доходов/расходов и аудит корректировок. Модуль заменил прежний standalone-сервис Payments, публикует события `deal.payment.updated` и хранит разбиение на доходные и расходные позиции внутри схемы `crm`. Каталог [`backend/payments`](backend/payments) содержит только легаси-материалы и используется как справка по мигрированному API.

Documents. Связывает сделки и полисы с каталогами серверного хранилища, хранит метаданные файлов, управляет доступами. Генерации документов нет; подготовленные инструкции — в [`backend/documents/README.md`](backend/documents/README.md).

Tasks (модуль CRM). Планирование и исполнение задач, напоминания назначенным пользователям, REST API и очереди задержек описаны в [`docs/api/tasks.md`](docs/api/tasks.md); SLA и автоматические сценарии появятся после [Этапа 1.1](docs/delivery-plan.md#2-приоритизация-последующих-этапов).【F:docs/api/tasks.md†L1-L39】

Notifications (модуль CRM). Отправка уведомлений по событиям (Telegram, внутренние SSE-потоки), интеграция с ботом и подтверждения доставки описаны в [`docs/api/notifications.md`](docs/api/notifications.md); Gateway проксирует канал `GET /api/v1/streams/notifications`.【F:docs/api/notifications.md†L1-L33】 Если Telegram-интеграция отключена (`CRM_NOTIFICATIONS_TELEGRAM_ENABLED=false`), модуль фиксирует служебное событие `notifications.telegram.skipped` и считает уведомление обработанным без попытки отправки.

Telegram Bot. Отдельный сервис, обеспечивающий персональные уведомления продавцов и исполнителей, а также быстрые сценарии: создание сделки из чат-команды, запуск напоминаний, подтверждение ключевых этапов. Архитектура и чек-листы на реализацию — в [`docs/architecture/bot.md`](docs/architecture/bot.md).

Reports. FastAPI-сервис с материализованными витринами PostgreSQL: отдаёт агрегаты по сделкам и предоставляет CLI для обновления витрин (подробности в [`backend/reports/README.md`](backend/reports/README.md)).

Backup. Резервное копирование баз, метаданных и файлового хранилища документов. Описание текущих скриптов и артефактов — в [`backups/README.md`](backups/README.md) и разделе [«Backup» технологического стека](docs/tech-stack.md#backup).

5. Хранение документов
Базовая схема каталогов на серверном файловом хранилище:

Клиент {ФИО или Наименование}/
  {Документы уровня клиента}.pdf
  Сделка {Краткое имя или ID}/
    Полис {Номер}/
      {Тип документа}_YYYYMMDD_{краткое описание}.pdf
Documents-сервис создаёт и поддерживает структуру каталогов внутри выделенного корня, выдаёт относительный путь и проверяет доступы. Документы уровня клиента (анкеты, доверенности, договоры на обслуживание и т.п.) хранятся прямо в корне папки клиента. Платёжные документы сохраняются в папках соответствующей сделки или полиса, без отдельной секции.

Метаданные (тип, относительный путь, автор, дата) сохраняются в БД Documents-сервиса.

Первоначально документы загружаются вручную пользователями через CRM.

### Варианты развёртывания хранилища на VPS
- **Локальный диск VPS** — каталоги создаются на файловой системе самого сервера; подходит для пилотного запуска и небольшой команды.
- **Подключённый volume (LVM, RAID, облачный диск)** — позволяет масштабировать объём и применять отдельные политики бэкапа.
- **Сетевое хранилище NFS/SFTP** — Documents подключает удалённый ресурс как точку монтирования, а управление доступами выполняется через системные ACL.
- **Self-hosted S3-совместимое хранилище (например, MinIO)** — сервис хранит документы в виде объектов, а в базе фиксируются ключи и версии; требуется шлюз доступа через S3 API.
- **Гибридные сценарии** — комбинация локального кэша и удалённого S3/NFS для балансировки скорости доступа и долговременного хранения.

6. Сквозной бизнес-процесс
Инициация сделки. Продавец создаёт клиента (если ещё не существует), заводит новую сделку и записывает в журнал ключевые параметры (например, пробег автомобиля, остаток долга). Возможна быстрая инициация через Telegram-бота: продавец в чате выбирает команду «Новая сделка», указывает клиента и ключевые параметры, после чего бот создаёт черновик сделки в CRM и ставит продавцу задачу дополнить данные. Независимо от канала создаётся папка сделки и складываются первичные документы. Назначается задача исполнителю на подготовку расчётов.

Работа по расчётам. Пользователь, ответственный за подготовку предложений, получает задачу и доступ к сделке и её папке, подготавливает расчёты в страховых компаниях, добавляет результаты и комментарии в сделку.

Выбор варианта. Ведущий пользователь обсуждает варианты с клиентом, фиксирует итоговое решение и ставит задачу на оформление выбранного полиса.

Оформление и оплата. Клиент оплачивает полис. Продавец или исполнитель, ведущий оформление, проверяет реквизиты и фиксирует факт оплаты в разделе платежей (при необходимости главный админ подтверждает операцию в журнале платежей). После подтверждения пользователь, ведущий оформление, завершает выпуск полиса и добавляет сканы в соответствующую папку.

Комиссия и расходы. Ответственный за сделку пользователь инициирует записи о комиссионных, скидках и выплатах, после чего суммы и статусы подтверждает главный админ или назначенный продавец/исполнитель с соответствующими правами. Учёт оплат ведётся в CRM/Deals: за него отвечает модуль платежей CRM вместо прежнего сервиса Payments.

*Примечание: распределение прав между продавцом, исполнителем и главным админом задаётся в RBAC-модели Auth; главный админ может делегировать подтверждение оплат и комиссий конкретным пользователям с операционными ролями.*

Мониторинг событий. CRM/Notifications настраивают напоминания о важных датах: следующем платеже, окончании срока полиса, потребности продления или других событиях. В первой поставке задачи обновляются вручную; автоматические SLA-переходы и триггеры уведомлений запланированы на [Этап 1.1](docs/delivery-plan.md#2-приоритизация-последующих-этапов). При наступлении события отправляются уведомления в CRM и через Telegram-бота, где продавец может подтвердить обработку или инициировать быструю сделку.

7. Нефункциональные требования (минимальный набор)
RBAC и аудит действий, особенно операций с платежами и документами.

Надёжное хранение данных: ежедневные бэкапы БД, дублирование ссылок на документы.

Базовая защита доступа к персональным данным без обязательного соответствия отраслевым регуляторам; действует упрощённая модель доступа (см. docs/security-and-access.md).

Гибкая система фильтрации и поиска по сделкам, полисам, платежам и документам.

Возможность расширять бизнес-процессы (например, добавлять повторяющиеся задачи для продлений).

8. Архитектура Telegram-бота

Бот реализован как отдельный сервис, подключённый к Notifications для доставки сообщений и к CRM/Deals для создания и обновления сделок. Основные компоненты:

- шлюз Telegram API, получающий команды и подтверждения от пользователей;
- обработчик сценариев, поддерживающий шаблоны быстрых сделок (инициация, уточнение параметров, подтверждение задач);
- очередь уведомлений, в которую Notifications публикует события (новые задачи, приближающиеся дедлайны, подтверждения оплат);
- модуль аутентификации, проверяющий привязку Telegram-аккаунта к пользователю CRM через Auth.

Схема взаимодействий фиксируется в разделе `docs/architecture/bot.md` (будет обновляться по мере детализации).

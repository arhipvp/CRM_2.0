# Архитектурный обзор

## 1. Общая структура сервисов

CRM состоит из набора специализированных сервисов, сгруппированных по доменам. Таблица ниже показывает основные функции и ключевые зависимости.

| Сервис | Основная ответственность | Ключевые зависимости |
| --- | --- | --- |
| Gateway / BFF | Единая точка входа для веб-клиента и Telegram-бота, оркестрация запросов, управление сессиями, агрегация данных | Redis (сессии, кеш), внутренние REST API сервисов, SSE-каналы CRM/Deals и Notifications, Consul |
| Auth | Управление пользователями, ролями, OAuth/OIDC-потоками, выдача токенов и проверка доступов | PostgreSQL (схема `auth`), Redis (одноразовые коды и токены), Gateway |
| CRM / Deals | Клиенты, сделки, расчёты, полисы, журналы, платежи и структура доходов/расходов, связанные задачи | PostgreSQL (схема `crm`), RabbitMQ (доменные события), Documents API |
| Tasks | Планирование и исполнение задач; в первой поставке — ручное назначение и статусы без SLA и автоматических напоминаний | PostgreSQL (схема `tasks`), RabbitMQ, Notifications |
| Notifications | Доставка уведомлений и триггеров в Telegram и внутренние уведомления CRM | RabbitMQ, Gateway (webhook Telegram), Redis (rate limiting) |
| Documents | Управление метаданными файлов и связью с серверным хранилищем документов | PostgreSQL (схема `documents`), файловая система или self-hosted S3, Auth |
| Telegram Bot | Канал обратной связи с пользователями, поддержка быстрых сценариев | Gateway (webhook), Auth (валидация пользователей), RabbitMQ |
| Audit | Централизованный журнал действий пользователей и системных событий | PostgreSQL (схема `audit`), RabbitMQ (подписка на критичные события) |
| Backup | Резервное копирование баз, политик и конфигураций | PostgreSQL (репликации и дампы), объектное хранилище |

Отдельного сервиса Payments больше нет: модуль платежей CRM работает внутри CRM/Deals, использует ту же схему `crm` и REST API. Базовые реквизиты операций лежат в `crm.payments`, детализация доходов и расходов — в таблицах `crm.payment_incomes` и `crm.payment_expenses`; события `deal.payment.updated`, `deal.payment.income.*` и `deal.payment.expense.*` обеспечивают синхронизацию данных для Notifications, Reports и Audit.

Детализация технологического стека сервисов Tasks и Notifications приведена в разделах [«Tasks»](tech-stack.md#tasks) и [«Notifications»](tech-stack.md#notifications) документа `docs/tech-stack.md`.

## 2. Взаимодействия и потоки данных

### 2.1 Синхронные вызовы

1. Веб-клиент обращается к Gateway/BFF, который определяет целевой сервис и обогащает ответы агрегированными данными.
2. Telegram-бот получает обновления через webhook, который завершается в Gateway; шлюз нормализует payload и проксирует его в сервис `backend/telegram-bot` (FastAPI + aiogram 3). Сервис проверяет HMAC-подпись заголовка `X-Telegram-Signature`, хранит состояние FSM в Redis и уже внутри диспетчера вызывает сценарии создания сделок, подтверждения задач и платежей.
3. Gateway проксирует обращения к внутренним REST API (Auth для авторизации, CRM/Deals для операций с клиентами, сделками и платежами) и поддерживает SSE-потоки CRM/Deals и Notifications (детали см. [`docs/api/streams.md`](api/streams.md)). Для восстановления соединений хранит `Last-Event-ID` и heartbeat-метки в Redis по шаблону `${REDIS_HEARTBEAT_PREFIX}:{channel}`. Платёжные обновления (включая изменения структуры доходов/расходов) входят в поток `deals` и не требуют отдельного канала.【F:backend/gateway/src/sse/upstream-sse.service.ts†L31-L68】
4. Для операций, требующих нескольких доменов, Gateway выполняет композицию данных и кеширует результаты в Redis.

### 2.2 Асинхронная шина RabbitMQ

RabbitMQ используется как единая шина событий и фоновых задач (форматы сообщений описаны в [`docs/integration-events.md`](integration-events.md)).

* **Очереди уведомлений** — Notifications формирует сообщения для Telegram-бота и внутренних уведомлений CRM. Dead-letter-очереди фиксируют недоставленные события, чтобы Audit мог разбирать инциденты.
* **Telegram Bot** — публикует CloudEvents `crm.deal.created`, `tasks.task.status_changed`, `crm.deal.payment.updated` в exchange `crm.domain` и `tasks.events`, а также подписан на очередь `telegram.bot.notifications` в `notifications.events` для доставки сообщений пользователям.
* **Фоновые задачи** — CRM/Deals и Tasks размещают длительные операции (подготовка отчётов, пересчёт SLA — после расширения в Этапе 1.1) в очередях с отложенной обработкой. Celery и worker-компоненты потребляют задачи, фиксируя результаты в своих PostgreSQL-схемах.

Асинхронное взаимодействие разгружает Gateway и позволяет временно деградировать сервисам без потери данных — сообщения сохраняются до восстановления потребителей.

### 2.3 Единый PostgreSQL-кластер

Все прикладные сервисы используют общий PostgreSQL-кластер, развёрнутый в конфигурации primary–standby с репликацией и бэкапами.

* Каждому сервису выделена отдельная схема (`auth`, `crm`, `tasks`, `documents`, `notifications`, `audit`).
* Изоляция достигается за счёт ролей с ограниченными правами и политик RLS, а общие справочники публикуются через представления только для чтения.
* Audit получает повышенные SLA на хранение и резервирование: все критичные события дублируются в отдельной партиционированной таблице.

### 2.4 Роль Gateway/BFF

Gateway — единственная точка входа для внешних клиентов (веб-клиент, Telegram-бот, интеграции).

* Выполняет аутентификацию по токенам, выданным Auth, и обогащает запросы данными о пользователе.
* Реализует политики rate limiting и кеширует агрегированные ответы в Redis.
* Маршрутизирует webhook-и (например, из Telegram) к соответствующим внутренним сервисам, обрабатывая подтверждения и обратные вызовы.
* Предоставляет fallback-сценарии: при недоступности отдельных сервисов сообщает о деградации и переключается на кэшированные данные, где это допустимо.

### 2.5 Сквозной поток данных (пример создания сделки)

1. Клиент инициирует создание сделки; запрос поступает в Gateway.
2. Gateway валидирует пользователя через Auth и записывает команду в CRM/Deals.
3. CRM/Deals создаёт записи в своей схеме PostgreSQL, публикует событие `deal.created` в RabbitMQ и создаёт задачу в Tasks.
4. Notifications подписывается на событие, формирует уведомления и отправляет их в очереди Telegram-бота и внутренней CRM.
5. Telegram-бот и внутренняя CRM доставляют сообщения пользователю; подтверждения через Gateway возвращаются в CRM/Deals, обновляя статус задачи.
6. При подтверждении оплаты продавец вызывает CRM API, который создаёт или обновляет запись `crm.payments`, пересчитывает связанные позиции доходов/расходов, публикует события `deal.payment.updated`, `deal.payment.income.*` и `deal.payment.expense.*`, а Audit фиксирует факт поступления и автора изменений.

### 2.6 Выдача прав к локальному файловому хранилищу

1. Auth хранит ролевую модель и при назначении пользователя в сделку публикует событие о выдаче доступа.
2. Documents подписывается на событие, проверяет состав участников и создаёт системные группы (POSIX/ACL) для клиента, сделки и полисов.
3. Service-аккаунт Documents применяет права к каталогу в файловой системе или self-hosted S3 (через политику bucket/папки).
4. Gateway при запросе на загрузку/скачивание проверяет права пользователя через Auth и выдаёт временный токен доступа к файлу (pre-signed URL или одноразовый ссылочный токен).
5. Audit фиксирует факт выдачи прав и обращений к файлам, что позволяет сверять соответствие записей в каталоге и ролевой модели.

## 3. Диаграмма взаимодействий

```mermaid
flowchart LR
    subgraph Client Channels
        FE[Web Client]
        TG[Telegram Bot]
    end

    FE -->|REST + SSE| GW[Gateway / BFF]
    TG -->|Webhook| GW

    GW -->|AuthN/AuthZ| AUTH[Auth]
    GW -->|Domain APIs| CRM[CRM / Deals]
    GW --> DOCS[Documents]
    GW --> TASKS[Tasks]
    GW --> NOTI[Notifications]

    subgraph RabbitMQ Bus
        CRM -->|domain events| EX
        NOTI -->|notifications| EX
        TASKS -->|background jobs| EX
        EX --> CRM
        EX --> TASKS
        EX --> NOTI
        EX --> AUD[Audit]
    end

    subgraph PostgreSQL Cluster
        AUTH
        CRM
        TASKS
        DOCS
        NOTI
        AUD
    end

    GW -->|Session Cache| REDIS[(Redis)]
    DOCS -->|Metadata| AUD
    BACKUP[(Backup Service)] -->|Snapshots| PostgreSQL Cluster
```

Диаграмма подчёркивает, что все прикладные сервисы работают с единой базой данных (с изолированными схемами) и общаются через асинхронную шину RabbitMQ, а Gateway выступает координатором внешних и внутренних взаимодействий для пользовательских каналов (веб-клиента и Telegram-бота).

## 4. Связанные документы

* [README.md](../README.md) — бизнес-контекст и пользовательские сценарии.
* [docs/api/README.md](api/README.md) — спецификации REST API и SSE каналов.
* [docs/integration-events.md](integration-events.md) — форматы сообщений RabbitMQ.
* [docs/data-model.md](data-model.md) — физическая модель данных (ER-диаграммы, таблицы и ограничения).
* [docs/tech-stack.md](tech-stack.md) — технологический стек и инфраструктурные решения (дополняет разделы 2.2–2.4).
* [docs/security-and-access.md](security-and-access.md) — политика доступа, соответствующая ролям и границам сервисов, включая локальное хранение документов.


## 5. ВАЖНО!!! Ориентировочный сценарий использования.

1. Есть еще какие-то несовпадения с моим сценарием?
2. "Продавец. Заводит сделку (если надо заводит нового клиента). Складывает все документы в папку сделки, пишит в журнал сделки нужную информацию. Ставит задачу на расчеты исполнителю.
3. Исполнитель. Получает задание. Открывает папку с документами. Делает расчеты. Вносит расчеты (расчеты это важная сущность) в сделку.
4. Далее продавец получает расчет. Согласовывает с клиентом варианты. Клиент выбирает вариант и сообщает Продавцу.
5. Далее продавец в сделке ставит задачу Исполнителю на оформление нужно варианта.
6. Далее клиент оплачивает полис.
7. Продавец или исполнитель складывает полис в папку, вносит полис в таблицу полисов в сделке (платежи, будущая комиссия и расходы вносятся автоматически или вручную).
8. Далее сделка откладывается (очередная дата просмотра) до следующего события (ближайшее окончание полиса или ближайший неоплаченный взнос).
9. Когда происходит поступление комиссии или вылата расходов это вносится в соответвующие поля."
# Архитектурный обзор

## 1. Общая структура сервисов

CRM состоит из набора специализированных сервисов, сгруппированных по доменам. Таблица ниже показывает основные функции и ключевые зависимости.

| Сервис | Основная ответственность | Ключевые зависимости |
| --- | --- | --- |
| Gateway / BFF | Единая точка входа для веб-клиента и Telegram-бота, оркестрация запросов, управление сессиями, агрегация данных | Redis (сессии, кеш), внутренние REST API сервисов, SSE-каналы CRM/Deals и Notifications, Consul |
| Auth | Управление пользователями, ролями, OAuth/OIDC-потоками, выдача токенов и проверка доступов | PostgreSQL (схема `auth`), Redis (одноразовые коды и токены), Gateway |
| CRM / Deals | Клиенты, сделки, расчёты, полисы, журналы, платежи и структура доходов/расходов, связанные задачи | PostgreSQL (схема `crm`), RabbitMQ (доменные события), Documents API |
| Tasks | Планирование и исполнение задач; в первой поставке — ручное назначение и статусы без SLA и автоматических напоминаний | PostgreSQL (схема `tasks`), RabbitMQ, Notifications |
| Notifications | Доставка уведомлений и триггеров в Telegram и внутренние уведомления CRM | RabbitMQ, Gateway (webhook Telegram), Redis (rate limiting) |
| Documents | Управление метаданными файлов и связью с Google Drive | PostgreSQL (схема `documents`), Google Drive API, Auth |
| Telegram Bot | Канал обратной связи с пользователями, поддержка быстрых сценариев | Gateway (webhook), Auth (валидация пользователей), RabbitMQ |
| Audit | Централизованный журнал действий пользователей и системных событий | PostgreSQL (схема `audit`), RabbitMQ (подписка на критичные события) |
| Backup | Резервное копирование баз, политик и конфигураций | PostgreSQL (репликации и дампы), объектное хранилище |

Отдельного сервиса Payments больше нет: модуль платежей CRM работает внутри CRM/Deals, использует ту же схему `crm` и REST API, а фронтенд получает обновления через общие эндпоинты CRM. Базовые реквизиты операций лежат в `crm.payments`, детализация доходов и расходов — в таблицах `crm.payment_incomes` и `crm.payment_expenses`; события `deal.payment.updated`, `deal.payment.income.*` и `deal.payment.expense.*` обеспечивают синхронизацию данных для Notifications, Reports и Audit.

Детализация технологического стека сервисов Tasks и Notifications приведена в разделах [«Tasks»](tech-stack.md#tasks) и [«Notifications»](tech-stack.md#notifications) документа `docs/tech-stack.md`.

## 2. Взаимодействия и потоки данных

### 2.1 Синхронные вызовы

1. Веб-клиент обращается к Gateway/BFF, который определяет целевой сервис и обогащает ответы агрегированными данными.
2. Telegram-бот получает обновления через webhook, который завершается в Gateway; шлюз нормализует payload и инициирует внутренние запросы.
3. Gateway проксирует обращения к внутренним REST API (Auth для авторизации, CRM/Deals для операций с клиентами, сделками и платежами) и поддерживает SSE-потоки CRM/Deals и Notifications для фронтенда (детали см. [`docs/api/streams.md`](api/streams.md)). Для восстановления соединений хранит `Last-Event-ID` и heartbeat-метки в Redis по шаблону `${REDIS_HEARTBEAT_PREFIX}:{channel}`. Платёжные обновления (включая изменения структуры доходов/расходов) входят в поток `deals` и не требуют отдельного канала.【F:backend/gateway/src/sse/upstream-sse.service.ts†L31-L68】
4. Для операций, требующих нескольких доменов, Gateway выполняет композицию данных и кеширует результаты в Redis.

### 2.2 Асинхронная шина RabbitMQ

RabbitMQ используется как единая шина событий и фоновых задач (форматы сообщений описаны в [`docs/integration-events.md`](integration-events.md)).

* **Очереди уведомлений** — Notifications формирует сообщения для Telegram-бота и внутренних уведомлений CRM. Dead-letter-очереди фиксируют недоставленные события, чтобы Audit мог разбирать инциденты.
* **Фоновые задачи** — CRM/Deals и Tasks размещают длительные операции (подготовка отчётов, пересчёт SLA — после расширения в Этапе 1.1) в очередях с отложенной обработкой. Celery и worker-компоненты потребляют задачи, фиксируя результаты в своих PostgreSQL-схемах.

Асинхронное взаимодействие разгружает Gateway и позволяет временно деградировать сервисам без потери данных — сообщения сохраняются до восстановления потребителей.

### 2.3 Единый PostgreSQL-кластер

Все прикладные сервисы используют общий PostgreSQL-кластер, развёрнутый в конфигурации primary–standby с репликацией и бэкапами.

* Каждому сервису выделена отдельная схема (`auth`, `crm`, `tasks`, `documents`, `notifications`, `audit`).
* Изоляция достигается за счёт ролей с ограниченными правами и политик RLS, а общие справочники публикуются через представления только для чтения.
* Audit получает повышенные SLA на хранение и резервирование: все критичные события дублируются в отдельной партиционированной таблице.

### 2.4 Роль Gateway/BFF

Gateway — единственная точка входа для внешних клиентов (веб-клиент, Telegram-бот, интеграции).

* Выполняет аутентификацию по токенам, выданным Auth, и обогащает запросы данными о пользователе.
* Реализует политики rate limiting и кеширует агрегированные ответы в Redis.
* Маршрутизирует webhook-и (например, из Telegram) к соответствующим внутренним сервисам, обрабатывая подтверждения и обратные вызовы.
* Предоставляет fallback-сценарии: при недоступности отдельных сервисов сообщает о деградации и переключается на кэшированные данные, где это допустимо.

### 2.5 Сквозной поток данных (пример создания сделки)

1. Пользователь инициирует создание сделки во фронтенде; запрос поступает в Gateway.
2. Gateway валидирует пользователя через Auth и записывает команду в CRM/Deals.
3. CRM/Deals создаёт записи в своей схеме PostgreSQL, публикует событие `deal.created` в RabbitMQ и создаёт задачу в Tasks.
4. Notifications подписывается на событие, формирует уведомления и отправляет их в очереди Telegram-бота и внутренней CRM.
5. Telegram-бот и внутренняя CRM доставляют сообщения пользователю; подтверждения через Gateway возвращаются в CRM/Deals, обновляя статус задачи.
6. При подтверждении оплаты продавец вызывает CRM API, который создаёт или обновляет запись `crm.payments`, пересчитывает связанные позиции доходов/расходов, публикует события `deal.payment.updated`, `deal.payment.income.*` и `deal.payment.expense.*`, а Audit фиксирует факт поступления и автора изменений.

## 3. Диаграмма взаимодействий

```mermaid
flowchart LR
    subgraph Client Channels
        FE[Web Client]
        TG[Telegram Bot]
    end

    FE -->|REST + SSE| GW[Gateway / BFF]
    TG -->|Webhook| GW

    GW -->|AuthN/AuthZ| AUTH[Auth]
    GW -->|Domain APIs| CRM[CRM / Deals]
    GW --> DOCS[Documents]
    GW --> TASKS[Tasks]
    GW --> NOTI[Notifications]

    subgraph RabbitMQ Bus
        CRM -->|domain events| EX
        NOTI -->|notifications| EX
        TASKS -->|background jobs| EX
        EX --> CRM
        EX --> TASKS
        EX --> NOTI
        EX --> AUD[Audit]
    end

    subgraph PostgreSQL Cluster
        AUTH
        CRM
        TASKS
        DOCS
        NOTI
        AUD
    end

    GW -->|Session Cache| REDIS[(Redis)]
    DOCS -->|Metadata| AUD
    BACKUP[(Backup Service)] -->|Snapshots| PostgreSQL Cluster
```

Диаграмма подчёркивает, что все прикладные сервисы работают с единой базой данных (с изолированными схемами) и общаются через асинхронную шину RabbitMQ, а Gateway выступает координатором внешних и внутренних взаимодействий для пользовательских каналов (веб-клиента и Telegram-бота).

## 4. Связанные документы

* [README.md](../README.md) — бизнес-контекст и пользовательские сценарии.
* [docs/api/README.md](api/README.md) — спецификации REST API и SSE каналов.
* [docs/integration-events.md](integration-events.md) — форматы сообщений RabbitMQ.
* [docs/data-model.md](data-model.md) — физическая модель данных (ER-диаграммы, таблицы и ограничения).
* [docs/tech-stack.md](tech-stack.md) — технологический стек и инфраструктурные решения (дополняет разделы 2.2–2.4).
* [docs/security-and-access.md](security-and-access.md) — политика доступа, соответствующая ролям и границам сервисов.

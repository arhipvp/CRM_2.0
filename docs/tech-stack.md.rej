diff a/docs/tech-stack.md b/docs/tech-stack.md	(rejected hunks)
@@ -189,63 +189,63 @@ CRM / Deals
 
 API: REST + SSE (через `sse-starlette` для стриминга событий сделок)
 
 Зависимости:
 
 PostgreSQL-схема crm
 
 Redis (очередь Celery)
 
 Использует общий кластер Redis, описанный в разделе «Брокеры сообщений и кэши», и разделяет мониторинг очередей Celery с Notifications.
 
 RabbitMQ выступает шиной доменных событий: сервис подписывается на exchange `payments.events`, читая сообщения через выделенную очередь `crm.payments-sync` с ключами `payments.*`. Для публикации собственных событий (`deal.created`, `deal.updated`, `task.assigned`, документы; SLA-события добавятся после Этапа 1.1) используется отдельный exchange `crm.events`, привязанный к очередям Notifications и Tasks (см. [архитектуру, раздел 2.2](architecture.md#22-асинхронная-шина-rabbitmq)). Подключение реализовано поверх `aio-pika` с подтверждением доставки (publisher confirms) и ручным ack со стороны консьюмера.
 
 Повторные попытки организованы через пару `crm.payments-sync.retry`/`crm.payments-sync.dlx`: основная очередь настроена на dead-letter при ошибках обработки, сообщения попадают в retry-очередь с TTL (60 секунд по умолчанию) и возвращаются в рабочую очередь ограниченное число раз. Невосстановимые сообщения сохраняются в `crm.payments-sync.dlx` для ручного анализа и корреляции с Audit.
 
 Интеграция с Documents-сервисом: загрузки и скачивания проходят через его API, который создаёт и управляет файлами в Google Drive; в PostgreSQL CRM хранит только метаданные (ID, ссылки, привязку к сущностям).
 
 Тестирование и деплой:
 
 Pytest + async-интеграции
 
 Alembic миграции, прогрев кеша
 
 Payments
 
-Язык: Kotlin (JVM 17)
+Язык: Java (JDK 17)
 
-Фреймворк: Spring Boot (WebFlux + Spring Cloud Stream)
+Фреймворк: Spring Boot WebFlux + Spring Cloud Stream (RabbitMQ binder)
 
-БД и очереди: Spring Data R2DBC (PostgreSQL), Spring AMQP (RabbitMQ)
+БД и очереди: Spring Data R2DBC (PostgreSQL), Flyway, StreamBridge + RabbitMQ
 
-API: REST, публикация событий в RabbitMQ
+API: REST (JSON) + SSE (`/streams/payments`), публикация и обработка событий `payments.events`
 
 Зависимости:
 
-PostgreSQL-схема payments
+PostgreSQL-схема payments (таблицы `payments`, `payment_history`, `payment_schedules` + справочники статусов/типов)
 
-RabbitMQ exchange payments.events с маршрутизацией по ключам операций (создание, изменение статусов, возвраты)
+RabbitMQ exchange `payments.events` с обработкой входящих статусов и генерацией собственных событий
 
 Внутренние справочники тарифов CRM с фиксированной валютой учёта RUB без дополнительных пересчётов
 
 Особенности работы
 ------------------
 
 * Все расчёты ведутся в базовой валюте CRM (RUB) без интеграции с внешними сервисами конвертации.
 * Gateway предоставляет REST-эндпоинты Payments только для внутренних клиентов (`/api/v1/payments/**`).
 
 Обмен событиями:
 
 * сервис создаёт сообщения в формате CloudEvents и публикует их в exchange payments.events через Spring AMQP с подтверждением доставки (publisher confirms);
 * Notifications, CRM/Deals и Tasks потребляют события через подписки на очереди с собственными routing key и поддержкой повторных попыток через dead-letter;
 * Audit фиксирует критичные события из отдельной очереди с выдержанным SLA на доставку.
 
 Тестирование и деплой:
 
 JUnit5 + Testcontainers для PostgreSQL и RabbitMQ
 
 Миграции Flyway выполняются из Spring Boot при старте и в CI/CD; конфигурация exchange, очередей и биндингов описана декларативно через Spring AMQP (RabbitAdmin) и применяется вместе с релизом; поэтапный rolling update
 
 Documents
 
 Язык: TypeScript (Node.js)
 

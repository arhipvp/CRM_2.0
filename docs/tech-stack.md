Назначение документа

Документ фиксирует базовые архитектурные принципы и технологические решения CRM-системы.
Он служит отправной точкой для команд разработки, эксплуатации и бизнес-заказчиков, помогая синхронизировать ожидания относительно сервисов и инфраструктуры.
Материал дополняет обзорные документы (README.md, docs/architecture.md, docs/security-and-access.md) и задаёт общие правила для детальных спецификаций отдельных сервисов.

Общие архитектурные принципы

Микросервисный подход. Функциональные домены выделяются в самостоятельные сервисы с чёткими API-контрактами, управляемыми через Gateway или BFF.

Единая база данных (на старте). Изначально сервисы используют одну реляционную СУБД с разграничением по схемам и правам; при росте — допускается декомпозиция по доменам.

Асинхронные коммуникации. Для обмена событиями и фоновых задач применяются очереди сообщений (RabbitMQ/Kafka) и публикация доменных событий.

Кеширование. Для ускорения чтения справочных и агрегированных данных используется Redis или аналогичный in-memory кеш с TTL и контролем согласованности.

Наблюдаемость и устойчивость. Все сервисы обязаны вести структурированные логи, метрики и трассировки (Prometheus, Grafana, OpenTelemetry), обеспечивать алерты и обработку ошибок с повторными попытками.

Управление конфигурацией и секретами. Конфигурации хранятся централизованно (Vault/SSM/Secrets Manager), секреты не попадают в репозиторий, развёртывание автоматизируется через CI/CD.

Безопасность по умолчанию. Реализованы единые механизмы аутентификации/авторизации, шифрование трафика, контроль доступа и регулярные проверки на соответствие требованиям безопасности.

Инфраструктура

Базы данных.

Основные сервисы (Auth, CRM/Deals, Payments, Tasks, Notifications) используют независимые PostgreSQL-кластеры с репликацией master–standby и резервным копированием в Backup-сервис.

Audit ведёт записи в отдельном инстансе PostgreSQL с включённым логированием длительных транзакций.

Брокеры сообщений и кэши.

Kafka развёрнута в продакшене как кластер из трёх брокеров под управлением Kubernetes-оператора (Strimzi). Для обеспечения надёжности включены rack-awareness, зеркалирование внутреннего топика __consumer_offsets и ретеншн критичных топиков не менее 7 дней. Обновления брокеров выполняются по rolling-стратегии, мониторинг и алертинг строятся на метриках Prometheus + Grafana, а резервные копии конфигураций и схем (Schema Registry) хранятся в Backup-сервисе. Payments публикует доменные события в общем топике payments.events этого кластера, консьюмеры запускаются с включёнными механизмами автокоммита и повторной доставки.

RabbitMQ используется для обмена доменными событиями между сервисами (Notifications, Telegram Bot, Tasks).

Redis — для кэширования сессий Gateway и хранения краткоживущих токенов подтверждения.

Контейнеризация и оркестрация.

Для локальной разработки сервисы поднимаются через Docker Compose.

В тестовой среде используется k3s, в продакшене — управляемый Kubernetes-кластер с Helm-чартами и сетевой политикой через Istio.

Логирование и мониторинг.

Логи собираются через Promtail в Loki.

Метрики собирает Prometheus, визуализация и алерты настраиваются в Grafana.

Трейсинг ключевых операций реализован через OpenTelemetry и Tempo.

CI/CD и GitOps.

GitHub Actions выполняет сборку, тесты и публикацию контейнеров в GitHub Container Registry.

Argo CD синхронизирует Kubernetes-кластер с GitOps-репозиторием инфраструктуры после автоматических проверок качества.

Интеграции
Google Drive

Авторизация по OAuth 2.0 с сервисным аккаунтом Google Workspace; ключи хранятся в Secrets Manager.

Documents-сервис управляет OAuth-токенами, получает доступ к корневой папке проекта и создаёт вложенные каталоги по структуре из раздела «Хранение документов» в README.

Метаданные файлов (ID Drive, ссылка, владельцы-сущности, хэш, автор, временные метки) сохраняются в PostgreSQL Documents-сервиса.

Telegram-бот

Бот принимает обновления через HTTPS-webhook, терминируемый в Gateway; используется обратный прокси с автоматическим обновлением TLS-сертификатов (Let’s Encrypt).

Команды и уведомления помещаются в очередь RabbitMQ, откуда их читают Notifications и CRM/Deals. Ответы пользователям отправляются асинхронно.

Привязка Telegram-пользователя к учётной записи CRM хранится в Auth-сервисе, доступ предоставляется по gRPC-API.

Политика хранения импортируемых файлов

Файлы загружаются напрямую в Google Drive; в CRM хранятся только ссылки и метаданные.

Служебные файлы, прошедшие импорт, помечаются TTL в 90 дней; по истечении срока Documents-сервис инициирует проверку продления и при отсутствии подтверждения удаляет их из Drive.

Метаданные и события импорта фиксируются в Audit и сохраняются бессрочно для восстановления истории действий.

Стек по сервисам
Gateway / BFF

Язык: TypeScript (Node.js LTS)

Фреймворк: NestJS с модулем @nestjs/axios для агрегации

БД и очереди: ioredis (Redis); прямой работы с PostgreSQL нет

API: REST (JSON) для фронтенда, внутренние вызовы — REST/gRPC

Зависимости и компоненты:

Redis для сессий и кеша

Service Discovery через Consul

Тестирование и деплой:

Контрактные тесты и smoke-тесты UI

Blue/green деплой без простоев

Auth

Язык: Kotlin (JVM 17)

Фреймворк: Spring Boot (WebFlux + Security)

БД и очереди: R2DBC (PostgreSQL), lettuce (Redis)

API: REST + OAuth2/OpenID Connect

Зависимости:

PostgreSQL-схема auth

Redis для токенов и кодов

SMTP-провайдер для e-mail подтверждений

Тестирование и деплой:

JUnit5 + Testcontainers

Миграции Liquibase, ротация JWT-ключей

CRM / Deals

Язык: Python 3.11

Фреймворк: FastAPI

БД и очереди: SQLAlchemy 2.0 + Alembic (PostgreSQL), Celery + Redis

API: REST + WebSocket

Зависимости:

PostgreSQL-схема crm

Redis (очередь Celery), S3-совместимый сторедж

Интеграция с Documents

Тестирование и деплой:

Pytest + async-интеграции

Alembic миграции, прогрев кеша

Payments

Язык: Go 1.21

Фреймворк: Fiber + go-chi/render

БД и очереди: pgx (PostgreSQL), sarama (Kafka)

API: REST, публикация событий в Kafka

Зависимости:

PostgreSQL-схема payments

Kafka topic payments.events

Внешний API валютных курсов через Gateway

Тестирование и деплой:

Unit-тесты и consumer-driven контракты

Rolling update, миграции golang-migrate

Documents

Язык: TypeScript (Node.js)

Фреймворк: NestJS + @googleapis/drive SDK

БД и очереди: TypeORM (PostgreSQL), BullMQ (Redis)

API: REST + Webhook

Зависимости:

PostgreSQL-схема documents

Redis кластер для синхронизации

Общие сервисные аккаунты Google Drive

Тестирование и деплой:

Интеграционные тесты с песочницей Drive

Проверка квот API, миграции TypeORM

Tasks / Notifications

Язык: Rust 1.72

Фреймворк: Actix Web + Tokio

БД и очереди: sqlx (PostgreSQL), lapin (RabbitMQ)

API: REST + WebSocket, публикация событий в RabbitMQ

Зависимости:

PostgreSQL-схема notifications

RabbitMQ кластер

Redis для временных токенов

Тестирование и деплой:

Нагрузочные тесты (k6), end-to-end сценарии

Canary-релизы, миграции sqlx migrate

Telegram Bot

Язык: Python 3.11

Фреймворк: aiogram 3

БД и очереди: asyncpg (PostgreSQL), aio-pika (RabbitMQ)

API: Вебхуки Telegram + внутренний REST Callback

Зависимости:

PostgreSQL-схема bot (readonly к auth и crm)

Очередь notifications.telegram

Redis для FSM и rate limiting

Тестирование и деплой:

Pytest-asyncio + моки Telegram API

End-to-end сценарии в staging, blue/green деплой

Дальнейшее развитие

Список технологий будет расширяться по мере детализации сервисов и инфраструктуры (СУБД, брокеры, деплой, интеграции).
Все изменения документируются в docs/ и проходят архитектурное ревью.
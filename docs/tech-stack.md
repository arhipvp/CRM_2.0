Назначение документа

Документ фиксирует базовые архитектурные принципы и технологические решения CRM-системы.
Он служит отправной точкой для команд разработки, эксплуатации и бизнес-заказчиков, помогая синхронизировать ожидания относительно сервисов и инфраструктуры.
Материал дополняет обзорные документы (README.md, docs/architecture.md, docs/security-and-access.md) и задаёт общие правила для детальных спецификаций отдельных сервисов.

Общие архитектурные принципы

Микросервисный подход. Функциональные домены выделяются в самостоятельные сервисы с чёткими API-контрактами, управляемыми через Gateway или BFF.

Единая база данных. Сервисы делят общий PostgreSQL-кластер, изолируясь на уровне схем, ролей и политик доступа; при существенном росте нагрузки возможен поэтапный переход к выделенным кластерам для отдельных доменов.

Асинхронные коммуникации. Для обмена событиями и фоновых задач применяются очереди сообщений (RabbitMQ) и публикация доменных событий.

Кеширование. Для ускорения чтения справочных и агрегированных данных используется Redis или аналогичный in-memory кеш с TTL и контролем согласованности.

Наблюдаемость и устойчивость. Все сервисы обязаны вести структурированные логи, метрики и трассировки (Prometheus, Grafana, OpenTelemetry), обеспечивать алерты и обработку ошибок с повторными попытками.

Управление конфигурацией и секретами. Конфигурации хранятся централизованно (Vault/SSM/Secrets Manager), секреты не попадают в репозиторий, развёртывание автоматизируется через CI/CD.

Безопасность по умолчанию. Реализованы единые механизмы аутентификации/авторизации, шифрование трафика, контроль доступа и регулярные проверки на соответствие требованиям безопасности.

Инфраструктура

Базы данных.

Основные сервисы (Auth, CRM/Deals, Payments, Tasks, Notifications) подключаются к единому PostgreSQL-кластеру. Изоляция достигается за счёт выделенных схем, отдельных ролей и политик row-level security там, где требуется. Кластер развёрнут в конфигурации primary–standby с резервным копированием в Backup-сервис.

Audit использует ту же инсталляцию PostgreSQL, но ведёт журналы в собственной схеме с включённым логированием длительных транзакций и повышенными SLA на хранение.

Брокеры сообщений и кэши.

RabbitMQ развёрнут в продакшене в кластере из трёх нод с quorum queue и mirrored classic queue для критичных очередей. Управление осуществляется через Kubernetes-оператор, конфигурации декларативно описаны в GitOps-репозитории. Для обеспечения надёжности включены автоматическое промоутирование лидеров, лимиты на TTL и длину очередей, а также политика dead-letter для повторяемых ошибок. Метрики собираются в Prometheus, алерты поддерживаются в Grafana, резервные копии конфигураций и политик выгружаются в Backup-сервис. Payments публикует доменные события в exchange payments.events, откуда Notifications, CRM/Deals и Tasks подписываются на соответствующие routing key.

Redis — для кэширования сессий Gateway и хранения краткоживущих токенов подтверждения.

Service discovery.

Consul развёрнут в Kubernetes через официальный Helm-чарт в конфигурации из трёх серверов и набора клиентских агентов на каждом
узле.

* Развёртывание: серверные узлы размещаются в отдельном StatefulSet с persistent volume и автоматическими health-checks;
  клиентские агенты доставляются DaemonSet-ом с sidecar-проверками для сервисов Gateway и внутренних API.
* Мониторинг: Consul-агенты экспортируют метрики в Prometheus, дашборды и алерты поддерживаются в Grafana, а технические события
  и аудит ACL транслируются в Loki.
* Резервирование и восстановление: снапшоты состояния ключ-значение и сервисных конфигураций отправляются в Backup-сервис,
  дополнительно по расписанию выгружаются ACL и intentions. Для DR-сценариев описаны инструкции восстановления кворума из
  последнего консистентного снапшота.

Контейнеризация и оркестрация.

Для локальной разработки сервисы поднимаются через Docker Compose.

В тестовой среде используется k3s, в продакшене — управляемый Kubernetes-кластер с Helm-чартами и сетевой политикой через Istio.

Логирование и мониторинг.

Логи собираются через Promtail в Loki.

Метрики собирает Prometheus, визуализация и алерты настраиваются в Grafana.

Трейсинг ключевых операций реализован через OpenTelemetry и Tempo.

CI/CD и GitOps.

GitHub Actions выполняет сборку, тесты и публикацию контейнеров в GitHub Container Registry.

Argo CD синхронизирует Kubernetes-кластер с GitOps-репозиторием инфраструктуры после автоматических проверок качества.

Интеграции
Google Drive

Авторизация по OAuth 2.0 с сервисным аккаунтом Google Workspace; ключи хранятся в Secrets Manager.

Documents-сервис управляет OAuth-токенами, получает доступ к корневой папке проекта и создаёт вложенные каталоги по структуре из раздела «Хранение документов» в README.

Метаданные файлов (ID Drive, ссылка, владельцы-сущности, хэш, автор, временные метки) сохраняются в PostgreSQL Documents-сервиса.

Telegram-бот

Бот принимает обновления через HTTPS-webhook, терминируемый в Gateway; используется обратный прокси с автоматическим обновлением TLS-сертификатов (Let’s Encrypt).

Команды и уведомления помещаются в очередь RabbitMQ, откуда их читают Notifications и CRM/Deals. Ответы пользователям отправляются асинхронно.

Привязка Telegram-пользователя к учётной записи CRM хранится в Auth-сервисе, доступ предоставляется по gRPC-API.

Политика хранения импортируемых файлов

Файлы загружаются через Documents-сервис напрямую в Google Drive; в PostgreSQL сохраняется только метаинформация (ID, ссылки, привязки к сущностям), а бинарные данные в CRM не хранятся.

Служебные файлы, прошедшие импорт, помечаются TTL в 90 дней; по истечении срока Documents-сервис инициирует проверку продления и при отсутствии подтверждения удаляет их из Drive.

Метаданные и события импорта фиксируются в Audit и сохраняются бессрочно для восстановления истории действий.

Стек по сервисам
Gateway / BFF

Язык: TypeScript (Node.js LTS)

Фреймворк: NestJS с модулем @nestjs/axios для агрегации

БД и очереди: ioredis (Redis); прямой работы с PostgreSQL нет

API: REST (JSON) для фронтенда, внутренние вызовы — REST/gRPC

Зависимости и компоненты:

Redis для сессий и кеша

Service Discovery через Consul

Тестирование и деплой:

Контрактные тесты и smoke-тесты UI

Blue/green деплой без простоев

Auth

Язык: Kotlin (JVM 17)

Фреймворк: Spring Boot (WebFlux + Security)

БД и очереди: R2DBC (PostgreSQL), lettuce (Redis)

API: REST + OAuth2/OpenID Connect

Зависимости:

PostgreSQL-схема auth

Redis для токенов и кодов

Notifications/Telegram Bot для выдачи одноразовых подтверждений входа, активации новых аккаунтов и быстрой валидации операций

CRM/Deals инициирует приглашение пользователя, а Telegram Bot доставляет одноразовый токен активации; подтверждение учётной записи происходит в Auth по предъявлению токена

Внутренний сервис администрирования для генерации стартовых токенов и восстановления доступа через CRM/Telegram с протоколированием операций в Audit

Тестирование и деплой:

JUnit5 + Testcontainers

Миграции Liquibase, ротация JWT-ключей

CRM / Deals

Язык: Python 3.11

Фреймворк: FastAPI

БД и очереди: SQLAlchemy 2.0 + Alembic (PostgreSQL), Celery + Redis

API: REST + WebSocket

Зависимости:

PostgreSQL-схема crm

Redis (очередь Celery)

Интеграция с Documents-сервисом: загрузки и скачивания проходят через его API, который создаёт и управляет файлами в Google Drive; в PostgreSQL CRM хранит только метаданные (ID, ссылки, привязку к сущностям).

Тестирование и деплой:

Pytest + async-интеграции

Alembic миграции, прогрев кеша

Payments

Язык: Kotlin (JVM 17)

Фреймворк: Spring Boot (WebFlux + Spring Cloud Stream)

БД и очереди: pgx (PostgreSQL), amqp091-go (RabbitMQ)

API: REST, публикация событий в RabbitMQ

Зависимости:

PostgreSQL-схема payments

RabbitMQ exchange payments.events с маршрутизацией по ключам операций (создание, изменение статусов, возвраты)

Внешний API валютных курсов через Gateway

Обмен событиями:

* сервис создаёт сообщения в формате CloudEvents и публикует их в exchange payments.events с подтверждением доставки (publisher confirms);
* Notifications, CRM/Deals и Tasks потребляют события через подписки на очереди с собственными routing key и поддержкой повторных попыток через dead-letter;
* Audit фиксирует критичные события из отдельной очереди с выдержанным SLA на доставку.

Тестирование и деплой:

JUnit5 + Testcontainers для PostgreSQL и Kafka

Миграции Flyway, поэтапный rolling update

Documents

Язык: TypeScript (Node.js)

Фреймворк: NestJS + @googleapis/drive SDK

БД и очереди: TypeORM (PostgreSQL), BullMQ (Redis)

API: REST + Webhook

Зависимости:

PostgreSQL-схема documents

Redis кластер для синхронизации

Общие сервисные аккаунты Google Drive

Тестирование и деплой:

Интеграционные тесты с песочницей Drive

Проверка квот API, миграции TypeORM

Tasks / Notifications

Язык: TypeScript (Node.js LTS)

Фреймворк: NestJS (@nestjs/websockets + @nestjs/schedule)

БД и очереди: TypeORM (PostgreSQL), @golevelup/nestjs-rabbitmq (RabbitMQ)

API: REST + WebSocket, публикация событий в RabbitMQ

Зависимости:

PostgreSQL-схема notifications

RabbitMQ кластер

Redis для временных токенов и rate limiting (ioredis)

Тестирование и деплой:

Jest + supertest, потребительские контракты для очередей

TypeORM миграции, canary-релизы

Telegram Bot

Язык: Python 3.11

Фреймворк: aiogram 3

БД и очереди: asyncpg (PostgreSQL), aio-pika (RabbitMQ)

API: Вебхуки Telegram + внутренний REST Callback

Зависимости:

PostgreSQL-схема bot (readonly к auth и crm)

Очередь notifications.telegram

Redis для FSM и rate limiting

Тестирование и деплой:

Pytest-asyncio + моки Telegram API

End-to-end сценарии в staging, blue/green деплой

Дальнейшее развитие

Список технологий будет расширяться по мере детализации сервисов и инфраструктуры (СУБД, брокеры, деплой, интеграции).
Все изменения документируются в docs/ и проходят архитектурное ревью.
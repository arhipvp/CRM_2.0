databaseChangeLog:
  - changeSet:
      id: 0006-partition-audit-events
      author: crm-platform
      remarks: >-
        Переводит audit.audit_events на партиционирование по occurred_at,
        обновляет внешние ключи и добавляет вспомогательные объекты для
        дальнейшего автоматического расширения.
      changes:
        - sql:
            comment: Добавляем в таблицу тегов ссылку на occurred_at события
            sql: |
              ALTER TABLE audit.audit_event_tags
                ADD COLUMN event_occurred_at TIMESTAMP WITH TIME ZONE;
        - sql:
            comment: Заполняем новое поле фактическими датами произошедшего события
            sql: |
              UPDATE audit.audit_event_tags tags
                 SET event_occurred_at = events.occurred_at
                FROM audit.audit_events events
               WHERE tags.event_id = events.id
                 AND tags.event_occurred_at IS NULL;
        - sql:
            comment: Запрещаем NULL в колонке event_occurred_at
            sql: |
              ALTER TABLE audit.audit_event_tags
                ALTER COLUMN event_occurred_at SET NOT NULL;
        - sql:
            comment: Удаляем старый внешний ключ (будет создан заново на составе из id и occurred_at)
            sql: |
              ALTER TABLE audit.audit_event_tags
                DROP CONSTRAINT IF EXISTS fk_audit_event_tags_event;
        - sql:
            comment: Снимаем ограничения перед переименованием исходной таблицы
            sql: |
              ALTER TABLE audit.audit_events
                DROP CONSTRAINT IF EXISTS uq_audit_events_dedup;
        - sql:
            sql: |
              ALTER TABLE audit.audit_events
                DROP CONSTRAINT IF EXISTS pk_audit_events;
        - sql:
            sql: |
              DROP INDEX IF EXISTS audit.uq_audit_events_event_id;
        - sql:
            sql: |
              DROP INDEX IF EXISTS audit.idx_audit_events_occurred_at;
        - sql:
            sql: |
              DROP INDEX IF EXISTS audit.idx_audit_events_event_type;
        - sql:
            comment: Переименовываем таблицу с данными для последующего копирования в новую структуру
            sql: |
              ALTER TABLE audit.audit_events RENAME TO audit_events_legacy;
        - sql:
            comment: Создаём секционированную таблицу audit.audit_events
            sql: |
              CREATE TABLE audit.audit_events (
                  id UUID NOT NULL DEFAULT gen_random_uuid(),
                  event_id VARCHAR(128),
                  event_type VARCHAR(128) NOT NULL,
                  event_source VARCHAR(128),
                  occurred_at TIMESTAMP WITH TIME ZONE NOT NULL,
                  payload JSONB,
                  received_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
                  CONSTRAINT uq_audit_events_dedup UNIQUE (event_type, occurred_at, event_source)
              ) PARTITION BY RANGE (occurred_at);
        - sql:
            comment: Глобальная уникальность идентификатора события достигается за счёт occurred_at
            sql: |
              CREATE UNIQUE INDEX uq_audit_events_event_id
                ON audit.audit_events (event_id, occurred_at)
                WHERE event_id IS NOT NULL;
        - sql:
            comment: Уникальность id + occurred_at требуется для внешнего ключа тегов
            sql: |
              ALTER TABLE audit.audit_events
                ADD CONSTRAINT uq_audit_events_id_occurred UNIQUE (id, occurred_at);
        - sql:
            comment: Индекс для сортировки и запроса по времени
            sql: |
              CREATE INDEX idx_audit_events_occurred_at
                ON audit.audit_events (occurred_at DESC);
        - sql:
            comment: Индекс для фильтрации по типу события
            sql: |
              CREATE INDEX idx_audit_events_event_type
                ON audit.audit_events (event_type);
        - sql:
            comment: Функция-шаблон для создания новых месячных партиций
            splitStatements: false
            sql: |
              CREATE OR REPLACE FUNCTION audit.ensure_audit_events_partition(month_start DATE)
              RETURNS VOID
              LANGUAGE plpgsql
              AS $$
              DECLARE
                  normalized DATE := date_trunc('month', month_start)::DATE;
                  month_end DATE := (normalized + INTERVAL '1 month')::DATE;
                  partition_suffix TEXT := to_char(normalized, 'YYYYMM');
                  partition_name TEXT := format('audit_events_%s', partition_suffix);
              BEGIN
                  EXECUTE format(
                      'CREATE TABLE IF NOT EXISTS audit.%I PARTITION OF audit.audit_events
                       FOR VALUES FROM (%L) TO (%L)',
                      partition_name,
                      normalized,
                      month_end
                  );
              END;
              $$;
        - sql:
            comment: Создаём историческую и будущие партиции на ближайшие 12 месяцев
            splitStatements: false
            sql: |
              DO $$
              DECLARE
                  current_month DATE := date_trunc('month', CURRENT_DATE)::DATE;
                  limit_month DATE := (current_month + INTERVAL '12 months')::DATE;
                  month_cursor DATE := current_month;
                  history_suffix TEXT := to_char(current_month, 'YYYYMM');
              BEGIN
                  EXECUTE format(
                      'CREATE TABLE IF NOT EXISTS audit.%I PARTITION OF audit.audit_events
                       FOR VALUES FROM (MINVALUE) TO (%L)',
                      format('audit_events_before_%s', history_suffix),
                      current_month
                  );

                  WHILE month_cursor < limit_month LOOP
                      PERFORM audit.ensure_audit_events_partition(month_cursor);
                      month_cursor := (month_cursor + INTERVAL '1 month')::DATE;
                  END LOOP;

                  EXECUTE 'CREATE TABLE IF NOT EXISTS audit.audit_events_default
                            PARTITION OF audit.audit_events DEFAULT';
              END;
              $$;
        - sql:
            comment: Переносим существующие данные в новую секционированную структуру
            sql: |
              INSERT INTO audit.audit_events (id, event_id, event_type, event_source, occurred_at, payload, received_at)
              SELECT id, event_id, event_type, event_source, occurred_at, payload, received_at
              FROM audit.audit_events_legacy;
        - sql:
            comment: Восстанавливаем связь тегов с событиями по составному ключу
            sql: |
              ALTER TABLE audit.audit_event_tags
                ADD CONSTRAINT fk_audit_event_tags_event
                FOREIGN KEY (event_id, event_occurred_at)
                REFERENCES audit.audit_events (id, occurred_at)
                ON UPDATE CASCADE
                ON DELETE CASCADE;
        - sql:
            comment: Удаляем временную таблицу
            sql: |
              DROP TABLE audit.audit_events_legacy;
      rollback:
        - sql:
            sql: |
              RAISE EXCEPTION 'Rollback для 0006-partition-audit-events не поддерживается';

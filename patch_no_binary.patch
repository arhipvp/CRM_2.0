diff --git a/backend/payments/README.md b/backend/payments/README.md
index 3144b91ce708431e48fa7576169ac1c7bd66f34c..c41b1a252ad668e1dfe3e1cb6de6a813aae23a93 100644
--- a/backend/payments/README.md
+++ b/backend/payments/README.md
@@ -1,31 +1,37 @@
 # Payments Service
 
 ## Назначение
 Payments учитывает финансовые операции (платежи, комиссии, возвраты), публикует события в RabbitMQ и опирается на внутренние справочники тарифов. Все расчёты выполняются в валюте RUB без дополнительных пересчётов или внешних конвертаций.【F:docs/architecture.md†L12-L17】【F:docs/tech-stack.md†L202-L236】
 
 ## Требования к окружению
 - JDK 17 и Gradle 8+ (Spring Boot WebFlux + Spring Cloud Stream).【F:docs/tech-stack.md†L204-L230】
 - PostgreSQL (схема `payments`) и RabbitMQ (exchange `payments.events`).【F:docs/architecture.md†L12-L13】【F:docs/tech-stack.md†L214-L236】
-- Переменные окружения `PAYMENTS_SERVICE_PORT`, `PAYMENTS_DATABASE_URL`, `PAYMENTS_RABBITMQ_URL` и связанные настройки (см. [`env.example`](../../env.example)).
+- Переменные окружения `PAYMENTS_SERVICE_PORT`, `PAYMENTS_JDBC_URL`, `PAYMENTS_R2DBC_URL`, `PAYMENTS_RABBITMQ_URL` и связанные настройки (см. [`env.example`](../../env.example)).
 
 ## Локальный запуск
-> **TODO:** сгенерировать Spring Boot WebFlux сервис через Spring Initializr, добавить зависимости Spring Cloud Stream и Flyway, настроить профили `local`/`dev`, Gradle-скрипты (`bootRun`, тесты с Testcontainers) и конфигурацию RabbitMQ/PostgreSQL.
+
+```bash
+cd backend/payments
+./gradlew bootRun -PspringProfile=local
+```
+
+Сервис ожидает переменные `PAYMENTS_R2DBC_URL`, `PAYMENTS_JDBC_URL`, `PAYMENTS_RABBITMQ_URL` и `PAYMENTS_SERVICE_PORT` из `.env` (см. [env.example](../../env.example)). SSE-поток доступен по адресу `GET http://localhost:${PAYMENTS_SERVICE_PORT}/streams/payments`.
 
 ## Миграции и скрипты
 - Миграции Flyway храните в каталоге [`migrations`](migrations/) и запускайте автоматически при старте приложения или отдельной задачей `./gradlew flywayMigrate`.【F:docs/tech-stack.md†L226-L230】
 - Скрипты настройки очередей (`payments.events`, маршрутизация) оформляются через Spring AMQP конфигурацию.
-- ⚠️ Миграции ещё не созданы и будут добавлены вместе с исходным кодом сервиса.
+Миграции применяются автоматически при старте профиля `local`/`dev`. Для ручного запуска используйте `./gradlew flywayMigrate -PspringProfile=local`.
 
 ## Запуск в Docker
 1. Соберите образ через Spring Boot buildpacks:
    ```bash
    ./gradlew bootBuildImage --imageName=crm-payments:local
    ```
 2. Запустите контейнер:
    ```bash
    docker run --rm -p ${PAYMENTS_SERVICE_PORT:-8083}:8083 --env-file ../../env.example crm-payments:local
    ```
 
 ## Полезные ссылки
 - Архитектурные взаимодействия Payments: [`docs/architecture.md`](../../docs/architecture.md#2-взаимодействия-и-потоки-данных).【F:docs/architecture.md†L61-L66】
 - Технологический стек и интеграции: [`docs/tech-stack.md`](../../docs/tech-stack.md#payments).【F:docs/tech-stack.md†L202-L230】
diff --git a/backend/payments/build.gradle b/backend/payments/build.gradle
new file mode 100644
index 0000000000000000000000000000000000000000..551cdc0be0834313206aa7071d36d783b3987414
--- /dev/null
+++ b/backend/payments/build.gradle
@@ -0,0 +1,83 @@
+plugins {
+    id 'java'
+    id 'org.springframework.boot' version '3.2.5'
+    id 'io.spring.dependency-management' version '1.1.4'
+    id 'org.flywaydb.flyway' version '9.22.3'
+}
+
+group = 'com.crm'
+version = '0.0.1-SNAPSHOT'
+description = 'CRM Payments Service'
+
+java {
+    toolchain {
+        languageVersion = JavaLanguageVersion.of(17)
+    }
+}
+
+configurations {
+    compileOnly {
+        extendsFrom annotationProcessor
+    }
+}
+
+repositories {
+    mavenCentral()
+}
+
+ext {
+    set('springCloudVersion', '2023.0.1')
+}
+
+dependencies {
+    implementation 'org.springframework.boot:spring-boot-starter-webflux'
+    implementation 'org.springframework.boot:spring-boot-starter-validation'
+    implementation 'org.springframework.boot:spring-boot-starter-actuator'
+    implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
+    implementation 'org.springframework.cloud:spring-cloud-starter-stream-rabbit'
+    implementation 'org.flywaydb:flyway-core'
+    runtimeOnly 'org.postgresql:postgresql'
+    runtimeOnly 'org.postgresql:r2dbc-postgresql'
+
+    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
+
+    testImplementation 'org.springframework.boot:spring-boot-starter-test'
+    testImplementation 'io.projectreactor:reactor-test'
+    testImplementation 'org.testcontainers:junit-jupiter'
+    testImplementation 'org.testcontainers:postgresql'
+    testImplementation 'org.testcontainers:rabbitmq'
+}
+
+dependencyManagement {
+    imports {
+        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
+    }
+}
+
+sourceSets {
+    main {
+        resources {
+            srcDir 'migrations'
+        }
+    }
+}
+
+tasks.withType(Test).configureEach {
+    useJUnitPlatform()
+    systemProperty 'spring.profiles.active', project.findProperty('springProfile') ?: 'test'
+}
+
+// Позволяет запускать `./gradlew bootRun -PspringProfile=dev`
+tasks.named('bootRun') {
+    systemProperty 'spring.profiles.active', project.findProperty('springProfile') ?: 'local'
+}
+
+flyway {
+    def rawUrl = System.getenv('PAYMENTS_DATABASE_URL')
+    url = rawUrl == null ? null : (rawUrl.startsWith('jdbc:') ? rawUrl : 'jdbc:' + rawUrl)
+    user = System.getenv('PAYMENTS_DB_USER')
+    password = System.getenv('PAYMENTS_DB_PASSWORD')
+    schemas = ['payments']
+    locations = ["filesystem:${project.projectDir}/migrations/db/migration"]
+    cleanDisabled = true
+}
diff --git a/backend/payments/gradle.properties b/backend/payments/gradle.properties
new file mode 100644
index 0000000000000000000000000000000000000000..b0c7997b107178c360fa1adb178dfdee2b56ac1d
--- /dev/null
+++ b/backend/payments/gradle.properties
@@ -0,0 +1,2 @@
+org.gradle.jvmargs=-Xmx1g -XX:MaxMetaspaceSize=512m
+org.gradle.java.installations.auto-download=true
diff --git a/backend/payments/gradle/wrapper/gradle-wrapper.properties b/backend/payments/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000000000000000000000000000000000..d4081da476bb3ee087bb538a0bb6718958af29a4
--- /dev/null
+++ b/backend/payments/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,7 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.3-bin.zip
+networkTimeout=10000
+validateDistributionUrl=true
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/backend/payments/gradlew b/backend/payments/gradlew
new file mode 100755
index 0000000000000000000000000000000000000000..23d15a9367071145e9c79bb4ddf879d1fbe78b5d
--- /dev/null
+++ b/backend/payments/gradlew
@@ -0,0 +1,251 @@
+#!/bin/sh
+
+#
+# Copyright © 2015-2021 the original authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+
+##############################################################################
+#
+#   Gradle start up script for POSIX generated by Gradle.
+#
+#   Important for running:
+#
+#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
+#       noncompliant, but you have some other compliant shell such as ksh or
+#       bash, then to run this script, type that shell name before the whole
+#       command line, like:
+#
+#           ksh Gradle
+#
+#       Busybox and similar reduced shells will NOT work, because this script
+#       requires all of these POSIX shell features:
+#         * functions;
+#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
+#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
+#         * compound commands having a testable exit status, especially «case»;
+#         * various built-in commands including «command», «set», and «ulimit».
+#
+#   Important for patching:
+#
+#   (2) This script targets any POSIX shell, so it avoids extensions provided
+#       by Bash, Ksh, etc; in particular arrays are avoided.
+#
+#       The "traditional" practice of packing multiple parameters into a
+#       space-separated string is a well documented source of bugs and security
+#       problems, so this is (mostly) avoided, by progressively accumulating
+#       options in "$@", and eventually passing that to Java.
+#
+#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
+#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
+#       see the in-line comments for details.
+#
+#       There are tweaks for specific operating systems such as AIX, CygWin,
+#       Darwin, MinGW, and NonStop.
+#
+#   (3) This script is generated from the Groovy template
+#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
+#       within the Gradle project.
+#
+#       You can find Gradle at https://github.com/gradle/gradle/.
+#
+##############################################################################
+
+# Attempt to set APP_HOME
+
+# Resolve links: $0 may be a link
+app_path=$0
+
+# Need this for daisy-chained symlinks.
+while
+    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
+    [ -h "$app_path" ]
+do
+    ls=$( ls -ld "$app_path" )
+    link=${ls#*' -> '}
+    case $link in             #(
+      /*)   app_path=$link ;; #(
+      *)    app_path=$APP_HOME$link ;;
+    esac
+done
+
+# This is normally unused
+# shellcheck disable=SC2034
+APP_BASE_NAME=${0##*/}
+# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
+APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD=maximum
+
+warn () {
+    echo "$*"
+} >&2
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+} >&2
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "$( uname )" in                #(
+  CYGWIN* )         cygwin=true  ;; #(
+  Darwin* )         darwin=true  ;; #(
+  MSYS* | MINGW* )  msys=true    ;; #(
+  NONSTOP* )        nonstop=true ;;
+esac
+
+CLASSPATH="\\\"\\\""
+
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD=$JAVA_HOME/jre/sh/java
+    else
+        JAVACMD=$JAVA_HOME/bin/java
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD=java
+    if ! command -v java >/dev/null 2>&1
+    then
+        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+fi
+
+# Increase the maximum file descriptors if we can.
+if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
+    case $MAX_FD in #(
+      max*)
+        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        MAX_FD=$( ulimit -H -n ) ||
+            warn "Could not query maximum file descriptor limit"
+    esac
+    case $MAX_FD in  #(
+      '' | soft) :;; #(
+      *)
+        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        ulimit -n "$MAX_FD" ||
+            warn "Could not set maximum file descriptor limit to $MAX_FD"
+    esac
+fi
+
+# Collect all arguments for the java command, stacking in reverse order:
+#   * args from the command line
+#   * the main class name
+#   * -classpath
+#   * -D...appname settings
+#   * --module-path (only if needed)
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if "$cygwin" || "$msys" ; then
+    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
+    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
+
+    JAVACMD=$( cygpath --unix "$JAVACMD" )
+
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    for arg do
+        if
+            case $arg in                                #(
+              -*)   false ;;                            # don't mess with options #(
+              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
+                    [ -e "$t" ] ;;                      #(
+              *)    false ;;
+            esac
+        then
+            arg=$( cygpath --path --ignore --mixed "$arg" )
+        fi
+        # Roll the args list around exactly as many times as the number of
+        # args, so each arg winds up back in the position where it started, but
+        # possibly modified.
+        #
+        # NB: a `for` loop captures its iteration list before it begins, so
+        # changing the positional parameters here affects neither the number of
+        # iterations, nor the values presented in `arg`.
+        shift                   # remove old arg
+        set -- "$@" "$arg"      # push replacement arg
+    done
+fi
+
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Collect all arguments for the java command:
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
+#     and any embedded shellness will be escaped.
+#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
+#     treated as '${Hostname}' itself on the command line.
+
+set -- \
+        "-Dorg.gradle.appname=$APP_BASE_NAME" \
+        -classpath "$CLASSPATH" \
+        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
+        "$@"
+
+# Stop when "xargs" is not available.
+if ! command -v xargs >/dev/null 2>&1
+then
+    die "xargs is not available"
+fi
+
+# Use "xargs" to parse quoted args.
+#
+# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
+#
+# In Bash we could simply go:
+#
+#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
+#   set -- "${ARGS[@]}" "$@"
+#
+# but POSIX shell has neither arrays nor command substitution, so instead we
+# post-process each arg (as a line of input to sed) to backslash-escape any
+# character that might be a shell metacharacter, then use eval to reverse
+# that process (while maintaining the separation between arguments), and wrap
+# the whole thing up as a single "set" statement.
+#
+# This will of course break if any of these variables contains a newline or
+# an unmatched quote.
+#
+
+eval "set -- $(
+        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
+        xargs -n1 |
+        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
+        tr '\n' ' '
+    )" '"$@"'
+
+exec "$JAVACMD" "$@"
diff --git a/backend/payments/gradlew.bat b/backend/payments/gradlew.bat
new file mode 100644
index 0000000000000000000000000000000000000000..5eed7ee8452842305a18a4eb967442683808226a
--- /dev/null
+++ b/backend/payments/gradlew.bat
@@ -0,0 +1,94 @@
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+@rem SPDX-License-Identifier: Apache-2.0
+@rem
+
+@if "%DEBUG%"=="" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%"=="" set DIRNAME=.
+@rem This is normally unused
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if %ERRORLEVEL% equ 0 goto execute
+
+echo. 1>&2
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto execute
+
+echo. 1>&2
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
+
+goto fail
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=
+
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*
+
+:end
+@rem End local scope for the variables with windows NT shell
+if %ERRORLEVEL% equ 0 goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+set EXIT_CODE=%ERRORLEVEL%
+if %EXIT_CODE% equ 0 set EXIT_CODE=1
+if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
+exit /b %EXIT_CODE%
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/backend/payments/migrations/db/migration/V20240117090000__create_payments.sql b/backend/payments/migrations/db/migration/V20240117090000__create_payments.sql
new file mode 100644
index 0000000000000000000000000000000000000000..b15eeee70a098034cd9a61fec2b214a0a79f69a6
--- /dev/null
+++ b/backend/payments/migrations/db/migration/V20240117090000__create_payments.sql
@@ -0,0 +1,30 @@
+CREATE SCHEMA IF NOT EXISTS payments;
+SET search_path TO payments;
+
+CREATE TABLE IF NOT EXISTS payment_statuses (
+    code VARCHAR(32) PRIMARY KEY,
+    description TEXT NOT NULL
+);
+
+CREATE TABLE IF NOT EXISTS payment_types (
+    code VARCHAR(32) PRIMARY KEY,
+    description TEXT NOT NULL
+);
+
+CREATE TABLE IF NOT EXISTS payments (
+    id UUID PRIMARY KEY,
+    deal_id UUID NOT NULL REFERENCES crm.deals(id),
+    policy_id UUID REFERENCES crm.policies(id),
+    initiator_user_id UUID NOT NULL REFERENCES auth.users(id),
+    amount NUMERIC(14, 2) NOT NULL CHECK (amount >= 0),
+    currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
+    status VARCHAR(32) NOT NULL DEFAULT 'PENDING' REFERENCES payment_statuses(code),
+    due_date TIMESTAMPTZ,
+    processed_at TIMESTAMPTZ,
+    description TEXT,
+    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
+);
+
+CREATE INDEX IF NOT EXISTS idx_payments_deal_id ON payments(deal_id);
+CREATE INDEX IF NOT EXISTS idx_payments_status ON payments(status);
diff --git a/backend/payments/migrations/db/migration/V20240117092000__create_payment_history.sql b/backend/payments/migrations/db/migration/V20240117092000__create_payment_history.sql
new file mode 100644
index 0000000000000000000000000000000000000000..825fbd4aa1b2b7b218df552dadb9b72b0250025e
--- /dev/null
+++ b/backend/payments/migrations/db/migration/V20240117092000__create_payment_history.sql
@@ -0,0 +1,13 @@
+SET search_path TO payments;
+
+CREATE TABLE IF NOT EXISTS payment_history (
+    id BIGSERIAL PRIMARY KEY,
+    payment_id UUID NOT NULL REFERENCES payments(id) ON DELETE CASCADE,
+    status VARCHAR(32) NOT NULL,
+    amount NUMERIC(14, 2) NOT NULL,
+    changed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+    description TEXT
+);
+
+CREATE INDEX IF NOT EXISTS idx_payment_history_payment_id ON payment_history(payment_id);
+CREATE INDEX IF NOT EXISTS idx_payment_history_changed_at ON payment_history(changed_at);
diff --git a/backend/payments/migrations/db/migration/V20240117094000__create_payment_schedules.sql b/backend/payments/migrations/db/migration/V20240117094000__create_payment_schedules.sql
new file mode 100644
index 0000000000000000000000000000000000000000..9ec3e4cf3fdb1af850365bd0a7dabdf37c4456e4
--- /dev/null
+++ b/backend/payments/migrations/db/migration/V20240117094000__create_payment_schedules.sql
@@ -0,0 +1,14 @@
+SET search_path TO payments;
+
+CREATE TABLE IF NOT EXISTS payment_schedules (
+    id UUID PRIMARY KEY,
+    deal_id UUID NOT NULL REFERENCES crm.deals(id),
+    payment_type VARCHAR(32) NOT NULL REFERENCES payment_types(code),
+    due_date DATE NOT NULL,
+    amount NUMERIC(14, 2) NOT NULL,
+    currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
+    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+    CONSTRAINT uq_payment_schedules UNIQUE (deal_id, payment_type, due_date)
+);
+
+CREATE INDEX IF NOT EXISTS idx_payment_schedules_deal_due ON payment_schedules(deal_id, due_date);
diff --git a/backend/payments/migrations/db/migration/V20240117100000__seed_payment_dictionaries.sql b/backend/payments/migrations/db/migration/V20240117100000__seed_payment_dictionaries.sql
new file mode 100644
index 0000000000000000000000000000000000000000..b1423e6601d45c24c1876588313928451d13e3e5
--- /dev/null
+++ b/backend/payments/migrations/db/migration/V20240117100000__seed_payment_dictionaries.sql
@@ -0,0 +1,16 @@
+SET search_path TO payments;
+
+INSERT INTO payment_statuses (code, description) VALUES
+    ('PENDING', 'Платёж ожидает подтверждения'),
+    ('PROCESSING', 'Платёж в обработке'),
+    ('COMPLETED', 'Платёж завершён'),
+    ('FAILED', 'Платёж отклонён или завершился ошибкой'),
+    ('CANCELLED', 'Платёж отменён клиентом или системой')
+ON CONFLICT (code) DO UPDATE SET description = EXCLUDED.description;
+
+INSERT INTO payment_types (code, description) VALUES
+    ('INITIAL', 'Первоначальный платёж по сделке'),
+    ('INSTALLMENT', 'Регулярный платёж по рассрочке'),
+    ('COMMISSION', 'Комиссия или сбор CRM'),
+    ('REFUND', 'Возврат клиенту')
+ON CONFLICT (code) DO UPDATE SET description = EXCLUDED.description;
diff --git a/backend/payments/settings.gradle b/backend/payments/settings.gradle
new file mode 100644
index 0000000000000000000000000000000000000000..a774a65967c80b42d49bc175f080488811feb581
--- /dev/null
+++ b/backend/payments/settings.gradle
@@ -0,0 +1,5 @@
+plugins {
+    id 'org.gradle.toolchains.foojay-resolver-convention' version '0.8.0'
+}
+
+rootProject.name = 'payments-service'
diff --git a/backend/payments/src/main/java/com/crm/payments/PaymentsServiceApplication.java b/backend/payments/src/main/java/com/crm/payments/PaymentsServiceApplication.java
new file mode 100644
index 0000000000000000000000000000000000000000..09f1d6e9ecfe39b19d74de7d87ab9e6cb7e48399
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/PaymentsServiceApplication.java
@@ -0,0 +1,12 @@
+package com.crm.payments;
+
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.autoconfigure.SpringBootApplication;
+
+@SpringBootApplication
+public class PaymentsServiceApplication {
+
+    public static void main(String[] args) {
+        SpringApplication.run(PaymentsServiceApplication.class, args);
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/api/PaymentController.java b/backend/payments/src/main/java/com/crm/payments/api/PaymentController.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f02d90bb50756205635322244e0446a363a3ed9
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/api/PaymentController.java
@@ -0,0 +1,54 @@
+package com.crm.payments.api;
+
+import com.crm.payments.api.dto.PaymentRequest;
+import com.crm.payments.api.dto.PaymentResponse;
+import com.crm.payments.api.dto.PaymentStreamEvent;
+import com.crm.payments.service.PaymentService;
+import jakarta.validation.Valid;
+import java.util.Optional;
+import java.util.UUID;
+import org.springframework.http.MediaType;
+import org.springframework.http.ResponseEntity;
+import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.PathVariable;
+import org.springframework.web.bind.annotation.PostMapping;
+import org.springframework.web.bind.annotation.RequestBody;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestParam;
+import org.springframework.web.bind.annotation.RestController;
+import reactor.core.publisher.Flux;
+import reactor.core.publisher.Mono;
+
+@RestController
+@RequestMapping({"/api/v1", "/api"})
+public class PaymentController {
+
+    private final PaymentService paymentService;
+
+    public PaymentController(PaymentService paymentService) {
+        this.paymentService = paymentService;
+    }
+
+    @GetMapping("/payments")
+    public Flux<PaymentResponse> listPayments(@RequestParam(name = "dealId", required = false) UUID dealId) {
+        return paymentService.findAll(Optional.ofNullable(dealId));
+    }
+
+    @GetMapping("/payments/{paymentId}")
+    public Mono<ResponseEntity<PaymentResponse>> getPayment(@PathVariable UUID paymentId) {
+        return paymentService.findById(paymentId)
+                .map(ResponseEntity::ok)
+                .defaultIfEmpty(ResponseEntity.notFound().build());
+    }
+
+    @PostMapping("/payments")
+    public Mono<ResponseEntity<PaymentResponse>> createPayment(@Valid @RequestBody PaymentRequest request) {
+        return paymentService.create(request)
+                .map(response -> ResponseEntity.status(201).body(response));
+    }
+
+    @GetMapping(path = "/streams/payments", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
+    public Flux<PaymentStreamEvent> streamPayments() {
+        return paymentService.streamEvents();
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/api/dto/PaymentRequest.java b/backend/payments/src/main/java/com/crm/payments/api/dto/PaymentRequest.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3305fdcb2f6f41d6fbfa97eeaabb64441ba88e2
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/api/dto/PaymentRequest.java
@@ -0,0 +1,86 @@
+package com.crm.payments.api.dto;
+
+import jakarta.validation.constraints.DecimalMin;
+import jakarta.validation.constraints.NotBlank;
+import jakarta.validation.constraints.NotNull;
+import java.math.BigDecimal;
+import java.time.OffsetDateTime;
+import java.util.UUID;
+
+public class PaymentRequest {
+
+    @NotNull
+    private UUID dealId;
+
+    private UUID policyId;
+
+    @NotNull
+    private UUID initiatorUserId;
+
+    @NotNull
+    @DecimalMin(value = "0.0", inclusive = false)
+    private BigDecimal amount;
+
+    @NotBlank
+    private String currency;
+
+    private OffsetDateTime dueDate;
+
+    private String description;
+
+    public UUID getDealId() {
+        return dealId;
+    }
+
+    public void setDealId(UUID dealId) {
+        this.dealId = dealId;
+    }
+
+    public UUID getPolicyId() {
+        return policyId;
+    }
+
+    public void setPolicyId(UUID policyId) {
+        this.policyId = policyId;
+    }
+
+    public UUID getInitiatorUserId() {
+        return initiatorUserId;
+    }
+
+    public void setInitiatorUserId(UUID initiatorUserId) {
+        this.initiatorUserId = initiatorUserId;
+    }
+
+    public BigDecimal getAmount() {
+        return amount;
+    }
+
+    public void setAmount(BigDecimal amount) {
+        this.amount = amount;
+    }
+
+    public String getCurrency() {
+        return currency;
+    }
+
+    public void setCurrency(String currency) {
+        this.currency = currency;
+    }
+
+    public OffsetDateTime getDueDate() {
+        return dueDate;
+    }
+
+    public void setDueDate(OffsetDateTime dueDate) {
+        this.dueDate = dueDate;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/api/dto/PaymentResponse.java b/backend/payments/src/main/java/com/crm/payments/api/dto/PaymentResponse.java
new file mode 100644
index 0000000000000000000000000000000000000000..617ebe813cc4e0dab0db165302c13556fe37385d
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/api/dto/PaymentResponse.java
@@ -0,0 +1,118 @@
+package com.crm.payments.api.dto;
+
+import com.crm.payments.domain.PaymentStatus;
+import java.math.BigDecimal;
+import java.time.OffsetDateTime;
+import java.util.UUID;
+
+public class PaymentResponse {
+
+    private UUID id;
+    private UUID dealId;
+    private UUID policyId;
+    private UUID initiatorUserId;
+    private BigDecimal amount;
+    private String currency;
+    private PaymentStatus status;
+    private OffsetDateTime dueDate;
+    private OffsetDateTime processedAt;
+    private String description;
+    private OffsetDateTime createdAt;
+    private OffsetDateTime updatedAt;
+
+    public UUID getId() {
+        return id;
+    }
+
+    public void setId(UUID id) {
+        this.id = id;
+    }
+
+    public UUID getDealId() {
+        return dealId;
+    }
+
+    public void setDealId(UUID dealId) {
+        this.dealId = dealId;
+    }
+
+    public UUID getPolicyId() {
+        return policyId;
+    }
+
+    public void setPolicyId(UUID policyId) {
+        this.policyId = policyId;
+    }
+
+    public UUID getInitiatorUserId() {
+        return initiatorUserId;
+    }
+
+    public void setInitiatorUserId(UUID initiatorUserId) {
+        this.initiatorUserId = initiatorUserId;
+    }
+
+    public BigDecimal getAmount() {
+        return amount;
+    }
+
+    public void setAmount(BigDecimal amount) {
+        this.amount = amount;
+    }
+
+    public String getCurrency() {
+        return currency;
+    }
+
+    public void setCurrency(String currency) {
+        this.currency = currency;
+    }
+
+    public PaymentStatus getStatus() {
+        return status;
+    }
+
+    public void setStatus(PaymentStatus status) {
+        this.status = status;
+    }
+
+    public OffsetDateTime getDueDate() {
+        return dueDate;
+    }
+
+    public void setDueDate(OffsetDateTime dueDate) {
+        this.dueDate = dueDate;
+    }
+
+    public OffsetDateTime getProcessedAt() {
+        return processedAt;
+    }
+
+    public void setProcessedAt(OffsetDateTime processedAt) {
+        this.processedAt = processedAt;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    public OffsetDateTime getCreatedAt() {
+        return createdAt;
+    }
+
+    public void setCreatedAt(OffsetDateTime createdAt) {
+        this.createdAt = createdAt;
+    }
+
+    public OffsetDateTime getUpdatedAt() {
+        return updatedAt;
+    }
+
+    public void setUpdatedAt(OffsetDateTime updatedAt) {
+        this.updatedAt = updatedAt;
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/api/dto/PaymentStreamEvent.java b/backend/payments/src/main/java/com/crm/payments/api/dto/PaymentStreamEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..7e996d8af4bdbf53296c8b56fd24903207e7b813
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/api/dto/PaymentStreamEvent.java
@@ -0,0 +1,77 @@
+package com.crm.payments.api.dto;
+
+import com.crm.payments.domain.PaymentStatus;
+import java.math.BigDecimal;
+import java.time.OffsetDateTime;
+import java.util.UUID;
+
+public class PaymentStreamEvent {
+
+    private String type;
+    private UUID paymentId;
+    private PaymentStatus status;
+    private BigDecimal amount;
+    private OffsetDateTime occurredAt;
+    private UUID dealId;
+
+    public PaymentStreamEvent() {
+    }
+
+    public PaymentStreamEvent(String type, UUID paymentId, PaymentStatus status, BigDecimal amount,
+            OffsetDateTime occurredAt, UUID dealId) {
+        this.type = type;
+        this.paymentId = paymentId;
+        this.status = status;
+        this.amount = amount;
+        this.occurredAt = occurredAt;
+        this.dealId = dealId;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public void setType(String type) {
+        this.type = type;
+    }
+
+    public UUID getPaymentId() {
+        return paymentId;
+    }
+
+    public void setPaymentId(UUID paymentId) {
+        this.paymentId = paymentId;
+    }
+
+    public PaymentStatus getStatus() {
+        return status;
+    }
+
+    public void setStatus(PaymentStatus status) {
+        this.status = status;
+    }
+
+    public BigDecimal getAmount() {
+        return amount;
+    }
+
+    public void setAmount(BigDecimal amount) {
+        this.amount = amount;
+    }
+
+    public OffsetDateTime getOccurredAt() {
+        return occurredAt;
+    }
+
+    public void setOccurredAt(OffsetDateTime occurredAt) {
+        this.occurredAt = occurredAt;
+    }
+
+    public UUID getDealId() {
+        return dealId;
+    }
+
+    public void setDealId(UUID dealId) {
+        this.dealId = dealId;
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/config/PaymentStreamConfig.java b/backend/payments/src/main/java/com/crm/payments/config/PaymentStreamConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..0131c9fe974026f993955a4c45893b8e45ca41c7
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/config/PaymentStreamConfig.java
@@ -0,0 +1,15 @@
+package com.crm.payments.config;
+
+import com.crm.payments.api.dto.PaymentStreamEvent;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import reactor.core.publisher.Sinks;
+
+@Configuration
+public class PaymentStreamConfig {
+
+    @Bean
+    public Sinks.Many<PaymentStreamEvent> paymentEventsSink() {
+        return Sinks.many().multicast().onBackpressureBuffer();
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/domain/PaymentEntity.java b/backend/payments/src/main/java/com/crm/payments/domain/PaymentEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..e31427a6fc9c3d570d6f70fe8d7ad09e9f0911f7
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/domain/PaymentEntity.java
@@ -0,0 +1,140 @@
+package com.crm.payments.domain;
+
+import java.math.BigDecimal;
+import java.time.OffsetDateTime;
+import java.util.UUID;
+import org.springframework.data.annotation.Id;
+import org.springframework.data.relational.core.mapping.Column;
+import org.springframework.data.relational.core.mapping.Table;
+
+@Table("payments")
+public class PaymentEntity {
+
+    @Id
+    private UUID id;
+
+    @Column("deal_id")
+    private UUID dealId;
+
+    @Column("policy_id")
+    private UUID policyId;
+
+    @Column("initiator_user_id")
+    private UUID initiatorUserId;
+
+    private BigDecimal amount;
+
+    private String currency;
+
+    private PaymentStatus status;
+
+    @Column("due_date")
+    private OffsetDateTime dueDate;
+
+    @Column("processed_at")
+    private OffsetDateTime processedAt;
+
+    private String description;
+
+    @Column("created_at")
+    private OffsetDateTime createdAt;
+
+    @Column("updated_at")
+    private OffsetDateTime updatedAt;
+
+    public UUID getId() {
+        return id;
+    }
+
+    public void setId(UUID id) {
+        this.id = id;
+    }
+
+    public UUID getDealId() {
+        return dealId;
+    }
+
+    public void setDealId(UUID dealId) {
+        this.dealId = dealId;
+    }
+
+    public UUID getPolicyId() {
+        return policyId;
+    }
+
+    public void setPolicyId(UUID policyId) {
+        this.policyId = policyId;
+    }
+
+    public UUID getInitiatorUserId() {
+        return initiatorUserId;
+    }
+
+    public void setInitiatorUserId(UUID initiatorUserId) {
+        this.initiatorUserId = initiatorUserId;
+    }
+
+    public BigDecimal getAmount() {
+        return amount;
+    }
+
+    public void setAmount(BigDecimal amount) {
+        this.amount = amount;
+    }
+
+    public String getCurrency() {
+        return currency;
+    }
+
+    public void setCurrency(String currency) {
+        this.currency = currency;
+    }
+
+    public PaymentStatus getStatus() {
+        return status;
+    }
+
+    public void setStatus(PaymentStatus status) {
+        this.status = status;
+    }
+
+    public OffsetDateTime getDueDate() {
+        return dueDate;
+    }
+
+    public void setDueDate(OffsetDateTime dueDate) {
+        this.dueDate = dueDate;
+    }
+
+    public OffsetDateTime getProcessedAt() {
+        return processedAt;
+    }
+
+    public void setProcessedAt(OffsetDateTime processedAt) {
+        this.processedAt = processedAt;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    public OffsetDateTime getCreatedAt() {
+        return createdAt;
+    }
+
+    public void setCreatedAt(OffsetDateTime createdAt) {
+        this.createdAt = createdAt;
+    }
+
+    public OffsetDateTime getUpdatedAt() {
+        return updatedAt;
+    }
+
+    public void setUpdatedAt(OffsetDateTime updatedAt) {
+        this.updatedAt = updatedAt;
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/domain/PaymentHistoryEntity.java b/backend/payments/src/main/java/com/crm/payments/domain/PaymentHistoryEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..9800ba2ce02611a8c2245492b2f49bcd4224eaee
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/domain/PaymentHistoryEntity.java
@@ -0,0 +1,75 @@
+package com.crm.payments.domain;
+
+import java.math.BigDecimal;
+import java.time.OffsetDateTime;
+import java.util.UUID;
+import org.springframework.data.annotation.Id;
+import org.springframework.data.relational.core.mapping.Column;
+import org.springframework.data.relational.core.mapping.Table;
+
+@Table("payment_history")
+public class PaymentHistoryEntity {
+
+    @Id
+    private Long id;
+
+    @Column("payment_id")
+    private UUID paymentId;
+
+    private PaymentStatus status;
+
+    private BigDecimal amount;
+
+    @Column("changed_at")
+    private OffsetDateTime changedAt;
+
+    private String description;
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public UUID getPaymentId() {
+        return paymentId;
+    }
+
+    public void setPaymentId(UUID paymentId) {
+        this.paymentId = paymentId;
+    }
+
+    public PaymentStatus getStatus() {
+        return status;
+    }
+
+    public void setStatus(PaymentStatus status) {
+        this.status = status;
+    }
+
+    public BigDecimal getAmount() {
+        return amount;
+    }
+
+    public void setAmount(BigDecimal amount) {
+        this.amount = amount;
+    }
+
+    public OffsetDateTime getChangedAt() {
+        return changedAt;
+    }
+
+    public void setChangedAt(OffsetDateTime changedAt) {
+        this.changedAt = changedAt;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/domain/PaymentScheduleEntity.java b/backend/payments/src/main/java/com/crm/payments/domain/PaymentScheduleEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..c790f051079442b2bffe2b8dcfd06e6eb1ec7ce3
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/domain/PaymentScheduleEntity.java
@@ -0,0 +1,88 @@
+package com.crm.payments.domain;
+
+import java.math.BigDecimal;
+import java.time.LocalDate;
+import java.time.OffsetDateTime;
+import java.util.UUID;
+import org.springframework.data.annotation.Id;
+import org.springframework.data.relational.core.mapping.Column;
+import org.springframework.data.relational.core.mapping.Table;
+
+@Table("payment_schedules")
+public class PaymentScheduleEntity {
+
+    @Id
+    private UUID id;
+
+    @Column("deal_id")
+    private UUID dealId;
+
+    @Column("payment_type")
+    private PaymentType paymentType;
+
+    @Column("due_date")
+    private LocalDate dueDate;
+
+    private BigDecimal amount;
+
+    private String currency;
+
+    @Column("created_at")
+    private OffsetDateTime createdAt;
+
+    public UUID getId() {
+        return id;
+    }
+
+    public void setId(UUID id) {
+        this.id = id;
+    }
+
+    public UUID getDealId() {
+        return dealId;
+    }
+
+    public void setDealId(UUID dealId) {
+        this.dealId = dealId;
+    }
+
+    public PaymentType getPaymentType() {
+        return paymentType;
+    }
+
+    public void setPaymentType(PaymentType paymentType) {
+        this.paymentType = paymentType;
+    }
+
+    public LocalDate getDueDate() {
+        return dueDate;
+    }
+
+    public void setDueDate(LocalDate dueDate) {
+        this.dueDate = dueDate;
+    }
+
+    public BigDecimal getAmount() {
+        return amount;
+    }
+
+    public void setAmount(BigDecimal amount) {
+        this.amount = amount;
+    }
+
+    public String getCurrency() {
+        return currency;
+    }
+
+    public void setCurrency(String currency) {
+        this.currency = currency;
+    }
+
+    public OffsetDateTime getCreatedAt() {
+        return createdAt;
+    }
+
+    public void setCreatedAt(OffsetDateTime createdAt) {
+        this.createdAt = createdAt;
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/domain/PaymentStatus.java b/backend/payments/src/main/java/com/crm/payments/domain/PaymentStatus.java
new file mode 100644
index 0000000000000000000000000000000000000000..53b77f44e26f6acf050d5e3971722a85e0aee5e7
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/domain/PaymentStatus.java
@@ -0,0 +1,9 @@
+package com.crm.payments.domain;
+
+public enum PaymentStatus {
+    PENDING,
+    PROCESSING,
+    COMPLETED,
+    FAILED,
+    CANCELLED
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/domain/PaymentType.java b/backend/payments/src/main/java/com/crm/payments/domain/PaymentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..6829ea8d74b4647ddd754792a695e0043d4fd710
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/domain/PaymentType.java
@@ -0,0 +1,8 @@
+package com.crm.payments.domain;
+
+public enum PaymentType {
+    INITIAL,
+    INSTALLMENT,
+    COMMISSION,
+    REFUND
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/messaging/PaymentStreamHandlers.java b/backend/payments/src/main/java/com/crm/payments/messaging/PaymentStreamHandlers.java
new file mode 100644
index 0000000000000000000000000000000000000000..edfba81df319251c3e028eb3ebfe640549196bae
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/messaging/PaymentStreamHandlers.java
@@ -0,0 +1,24 @@
+package com.crm.payments.messaging;
+
+import com.crm.payments.messaging.dto.PaymentQueueEvent;
+import com.crm.payments.service.PaymentService;
+import java.util.function.Consumer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import reactor.core.publisher.Flux;
+
+@Configuration
+public class PaymentStreamHandlers {
+
+    private static final Logger log = LoggerFactory.getLogger(PaymentStreamHandlers.class);
+
+    @Bean
+    public Consumer<Flux<PaymentQueueEvent>> paymentEventsConsumer(PaymentService paymentService) {
+        return flux -> flux.flatMap(paymentService::handleQueueEvent)
+                .doOnError(error -> log.error("Ошибка обработки события payments.events", error))
+                .onErrorResume(error -> Flux.empty())
+                .subscribe();
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/messaging/dto/PaymentQueueEvent.java b/backend/payments/src/main/java/com/crm/payments/messaging/dto/PaymentQueueEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..4319f772f3ce567ac9f2f4678b16ff2440050f5f
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/messaging/dto/PaymentQueueEvent.java
@@ -0,0 +1,74 @@
+package com.crm.payments.messaging.dto;
+
+import com.crm.payments.domain.PaymentStatus;
+import java.math.BigDecimal;
+import java.time.OffsetDateTime;
+import java.util.Map;
+import java.util.UUID;
+
+public class PaymentQueueEvent {
+
+    private UUID paymentId;
+    private UUID dealId;
+    private PaymentStatus status;
+    private BigDecimal amount;
+    private OffsetDateTime occurredAt;
+    private String eventType;
+    private Map<String, Object> metadata;
+
+    public UUID getPaymentId() {
+        return paymentId;
+    }
+
+    public void setPaymentId(UUID paymentId) {
+        this.paymentId = paymentId;
+    }
+
+    public UUID getDealId() {
+        return dealId;
+    }
+
+    public void setDealId(UUID dealId) {
+        this.dealId = dealId;
+    }
+
+    public PaymentStatus getStatus() {
+        return status;
+    }
+
+    public void setStatus(PaymentStatus status) {
+        this.status = status;
+    }
+
+    public BigDecimal getAmount() {
+        return amount;
+    }
+
+    public void setAmount(BigDecimal amount) {
+        this.amount = amount;
+    }
+
+    public OffsetDateTime getOccurredAt() {
+        return occurredAt;
+    }
+
+    public void setOccurredAt(OffsetDateTime occurredAt) {
+        this.occurredAt = occurredAt;
+    }
+
+    public String getEventType() {
+        return eventType;
+    }
+
+    public void setEventType(String eventType) {
+        this.eventType = eventType;
+    }
+
+    public Map<String, Object> getMetadata() {
+        return metadata;
+    }
+
+    public void setMetadata(Map<String, Object> metadata) {
+        this.metadata = metadata;
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/repository/PaymentHistoryRepository.java b/backend/payments/src/main/java/com/crm/payments/repository/PaymentHistoryRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..9786d2c0e3e3026c2d426c36d6c7281dd51196b7
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/repository/PaymentHistoryRepository.java
@@ -0,0 +1,11 @@
+package com.crm.payments.repository;
+
+import com.crm.payments.domain.PaymentHistoryEntity;
+import java.util.UUID;
+import org.springframework.data.repository.reactive.ReactiveCrudRepository;
+import reactor.core.publisher.Flux;
+
+public interface PaymentHistoryRepository extends ReactiveCrudRepository<PaymentHistoryEntity, Long> {
+
+    Flux<PaymentHistoryEntity> findAllByPaymentIdOrderByChangedAtAsc(UUID paymentId);
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/repository/PaymentRepository.java b/backend/payments/src/main/java/com/crm/payments/repository/PaymentRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f02abf523899e903754a633bd54907832193640
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/repository/PaymentRepository.java
@@ -0,0 +1,11 @@
+package com.crm.payments.repository;
+
+import com.crm.payments.domain.PaymentEntity;
+import java.util.UUID;
+import org.springframework.data.repository.reactive.ReactiveCrudRepository;
+import reactor.core.publisher.Flux;
+
+public interface PaymentRepository extends ReactiveCrudRepository<PaymentEntity, UUID> {
+
+    Flux<PaymentEntity> findAllByDealId(UUID dealId);
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/repository/PaymentScheduleRepository.java b/backend/payments/src/main/java/com/crm/payments/repository/PaymentScheduleRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..5bdca14ed42716e3919a85d6c0a3b2475a1c03d0
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/repository/PaymentScheduleRepository.java
@@ -0,0 +1,12 @@
+package com.crm.payments.repository;
+
+import com.crm.payments.domain.PaymentScheduleEntity;
+import java.time.LocalDate;
+import java.util.UUID;
+import org.springframework.data.repository.reactive.ReactiveCrudRepository;
+import reactor.core.publisher.Flux;
+
+public interface PaymentScheduleRepository extends ReactiveCrudRepository<PaymentScheduleEntity, UUID> {
+
+    Flux<PaymentScheduleEntity> findAllByDealIdAndDueDateAfterOrderByDueDateAsc(UUID dealId, LocalDate fromDate);
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/service/PaymentMapper.java b/backend/payments/src/main/java/com/crm/payments/service/PaymentMapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..5433b1b95918baed3896ee9099f381f793431627
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/service/PaymentMapper.java
@@ -0,0 +1,47 @@
+package com.crm.payments.service;
+
+import com.crm.payments.api.dto.PaymentRequest;
+import com.crm.payments.api.dto.PaymentResponse;
+import com.crm.payments.domain.PaymentEntity;
+import com.crm.payments.domain.PaymentStatus;
+import java.time.OffsetDateTime;
+import java.util.UUID;
+import org.springframework.stereotype.Component;
+
+@Component
+public class PaymentMapper {
+
+    public PaymentEntity fromRequest(PaymentRequest request) {
+        PaymentEntity entity = new PaymentEntity();
+        entity.setId(UUID.randomUUID());
+        entity.setDealId(request.getDealId());
+        entity.setPolicyId(request.getPolicyId());
+        entity.setInitiatorUserId(request.getInitiatorUserId());
+        entity.setAmount(request.getAmount());
+        entity.setCurrency(request.getCurrency());
+        entity.setStatus(PaymentStatus.PENDING);
+        entity.setDueDate(request.getDueDate());
+        entity.setDescription(request.getDescription());
+        OffsetDateTime now = OffsetDateTime.now();
+        entity.setCreatedAt(now);
+        entity.setUpdatedAt(now);
+        return entity;
+    }
+
+    public PaymentResponse toResponse(PaymentEntity entity) {
+        PaymentResponse response = new PaymentResponse();
+        response.setId(entity.getId());
+        response.setDealId(entity.getDealId());
+        response.setPolicyId(entity.getPolicyId());
+        response.setInitiatorUserId(entity.getInitiatorUserId());
+        response.setAmount(entity.getAmount());
+        response.setCurrency(entity.getCurrency());
+        response.setStatus(entity.getStatus());
+        response.setDueDate(entity.getDueDate());
+        response.setProcessedAt(entity.getProcessedAt());
+        response.setDescription(entity.getDescription());
+        response.setCreatedAt(entity.getCreatedAt());
+        response.setUpdatedAt(entity.getUpdatedAt());
+        return response;
+    }
+}
diff --git a/backend/payments/src/main/java/com/crm/payments/service/PaymentService.java b/backend/payments/src/main/java/com/crm/payments/service/PaymentService.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7e52acd4d1165ee775df03ac9e78a7c07fbd5a4
--- /dev/null
+++ b/backend/payments/src/main/java/com/crm/payments/service/PaymentService.java
@@ -0,0 +1,151 @@
+package com.crm.payments.service;
+
+import com.crm.payments.api.dto.PaymentRequest;
+import com.crm.payments.api.dto.PaymentResponse;
+import com.crm.payments.api.dto.PaymentStreamEvent;
+import com.crm.payments.domain.PaymentEntity;
+import com.crm.payments.domain.PaymentHistoryEntity;
+import com.crm.payments.domain.PaymentStatus;
+import com.crm.payments.messaging.dto.PaymentQueueEvent;
+import com.crm.payments.repository.PaymentHistoryRepository;
+import com.crm.payments.repository.PaymentRepository;
+import java.time.OffsetDateTime;
+import java.util.Optional;
+import java.util.UUID;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.cloud.stream.function.StreamBridge;
+import org.springframework.stereotype.Service;
+import reactor.core.publisher.Flux;
+import reactor.core.publisher.Mono;
+import reactor.core.publisher.Sinks;
+
+@Service
+public class PaymentService {
+
+    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);
+    private static final String PAYMENT_EVENTS_OUTPUT = "paymentEvents-out-0";
+
+    private final PaymentRepository paymentRepository;
+    private final PaymentHistoryRepository paymentHistoryRepository;
+    private final PaymentMapper paymentMapper;
+    private final StreamBridge streamBridge;
+    private final Sinks.Many<PaymentStreamEvent> streamSink;
+
+    public PaymentService(
+            PaymentRepository paymentRepository,
+            PaymentHistoryRepository paymentHistoryRepository,
+            PaymentMapper paymentMapper,
+            StreamBridge streamBridge,
+            Sinks.Many<PaymentStreamEvent> streamSink) {
+        this.paymentRepository = paymentRepository;
+        this.paymentHistoryRepository = paymentHistoryRepository;
+        this.paymentMapper = paymentMapper;
+        this.streamBridge = streamBridge;
+        this.streamSink = streamSink;
+    }
+
+    public Flux<PaymentResponse> findAll(Optional<UUID> dealId) {
+        Flux<PaymentEntity> source = dealId
+                .map(paymentRepository::findAllByDealId)
+                .orElseGet(paymentRepository::findAll);
+        return source.map(paymentMapper::toResponse);
+    }
+
+    public Mono<PaymentResponse> findById(UUID paymentId) {
+        return paymentRepository.findById(paymentId)
+                .map(paymentMapper::toResponse);
+    }
+
+    public Mono<PaymentResponse> create(PaymentRequest request) {
+        PaymentEntity entity = paymentMapper.fromRequest(request);
+        return paymentRepository.save(entity)
+                .flatMap(saved -> recordHistory(saved, "payment.created", saved.getAmount())
+                        .thenReturn(saved))
+                .doOnNext(saved -> publishQueueEvent("payment.created", saved, saved.getAmount()))
+                .map(paymentMapper::toResponse)
+                .doOnNext(response -> emitStreamEvent("payment.created", response.getId(), response.getStatus(),
+                        response.getAmount(), response.getDealId()))
+                .doOnSuccess(response -> log.info("Создан платёж {} для сделки {}", response.getId(),
+                        response.getDealId()));
+    }
+
+    public Mono<Void> handleQueueEvent(PaymentQueueEvent event) {
+        if (event == null || event.getPaymentId() == null) {
+            log.warn("Получено пустое событие очереди payments.events: {}", event);
+            return Mono.empty();
+        }
+
+        if ("payment.created".equalsIgnoreCase(event.getEventType())) {
+            log.debug("Пропускаем событие {} для платежа {} — создание зафиксировано локально", event.getEventType(),
+                    event.getPaymentId());
+            return Mono.empty();
+        }
+
+        return paymentRepository.findById(event.getPaymentId())
+                .flatMap(entity -> applyEventToEntity(entity, event))
+                .switchIfEmpty(Mono.defer(() -> {
+                    log.warn("Событие {} относится к неизвестному платежу {}", event.getEventType(),
+                            event.getPaymentId());
+                    return Mono.empty();
+                }))
+                .then();
+    }
+
+    public Flux<PaymentStreamEvent> streamEvents() {
+        return streamSink.asFlux();
+    }
+
+    private Mono<PaymentEntity> applyEventToEntity(PaymentEntity entity, PaymentQueueEvent event) {
+        if (event.getStatus() != null) {
+            entity.setStatus(event.getStatus());
+        }
+        if (event.getAmount() != null) {
+            entity.setAmount(event.getAmount());
+        }
+        entity.setUpdatedAt(OffsetDateTime.now());
+        if (event.getStatus() == PaymentStatus.COMPLETED) {
+            entity.setProcessedAt(Optional.ofNullable(event.getOccurredAt()).orElseGet(OffsetDateTime::now));
+        }
+
+        return paymentRepository.save(entity)
+                .flatMap(saved -> recordHistory(saved, event.getEventType(), event.getAmount())
+                        .thenReturn(saved))
+                .doOnNext(saved -> emitStreamEvent(event.getEventType(), saved.getId(), saved.getStatus(),
+                        saved.getAmount(), saved.getDealId()))
+                .doOnNext(saved -> log.info("Обновлён платёж {} статус {}", saved.getId(), saved.getStatus()));
+    }
+
+    private Mono<PaymentHistoryEntity> recordHistory(PaymentEntity entity, String eventType, java.math.BigDecimal amount) {
+        PaymentHistoryEntity history = new PaymentHistoryEntity();
+        history.setPaymentId(entity.getId());
+        history.setStatus(entity.getStatus());
+        history.setAmount(amount != null ? amount : entity.getAmount());
+        history.setChangedAt(OffsetDateTime.now());
+        history.setDescription(eventType);
+        return paymentHistoryRepository.save(history);
+    }
+
+    private void publishQueueEvent(String type, PaymentEntity entity, java.math.BigDecimal amount) {
+        PaymentQueueEvent event = new PaymentQueueEvent();
+        event.setEventType(type);
+        event.setPaymentId(entity.getId());
+        event.setDealId(entity.getDealId());
+        event.setStatus(entity.getStatus());
+        event.setAmount(amount != null ? amount : entity.getAmount());
+        event.setOccurredAt(OffsetDateTime.now());
+        boolean sent = streamBridge.send(PAYMENT_EVENTS_OUTPUT, event);
+        if (!sent) {
+            log.warn("Не удалось опубликовать событие {} в payments.events", type);
+        }
+    }
+
+    private void emitStreamEvent(String type, UUID paymentId, PaymentStatus status,
+            java.math.BigDecimal amount, UUID dealId) {
+        PaymentStreamEvent event = new PaymentStreamEvent(type, paymentId, status, amount, OffsetDateTime.now(), dealId);
+        Sinks.EmitResult result = streamSink.tryEmitNext(event);
+        if (!Sinks.EmitResult.OK.equals(result)) {
+            log.debug("Не удалось доставить событие SSE {} для платежа {}: {}", type, paymentId, result);
+        }
+    }
+}
diff --git a/backend/payments/src/main/resources/application-dev.yml b/backend/payments/src/main/resources/application-dev.yml
new file mode 100644
index 0000000000000000000000000000000000000000..1c44a912eac9c2c92892768db8f2ca0ca0d0c309
--- /dev/null
+++ b/backend/payments/src/main/resources/application-dev.yml
@@ -0,0 +1,23 @@
+spring:
+  config:
+    activate:
+      on-profile: dev
+  r2dbc:
+    url: ${PAYMENTS_DEV_R2DBC_URL:${PAYMENTS_R2DBC_URL}}
+    username: ${PAYMENTS_DEV_DB_USER:${PAYMENTS_DB_USER}}
+    password: ${PAYMENTS_DEV_DB_PASSWORD:${PAYMENTS_DB_PASSWORD}}
+  flyway:
+    enabled: true
+    url: ${PAYMENTS_DEV_JDBC_URL:${PAYMENTS_JDBC_URL:${PAYMENTS_DATABASE_URL}}}
+    user: ${PAYMENTS_DEV_DB_USER:${PAYMENTS_DB_USER}}
+    password: ${PAYMENTS_DEV_DB_PASSWORD:${PAYMENTS_DB_PASSWORD}}
+    default-schema: payments
+    locations: classpath:db/migration
+  rabbitmq:
+    uri: ${PAYMENTS_DEV_RABBITMQ_URL:${PAYMENTS_RABBITMQ_URL}}
+
+management:
+  endpoints:
+    web:
+      exposure:
+        include: "health,info,metrics,prometheus"
diff --git a/backend/payments/src/main/resources/application-local.yml b/backend/payments/src/main/resources/application-local.yml
new file mode 100644
index 0000000000000000000000000000000000000000..f26cd655f99e3a9e1e0c5c7d5365b6e034f578d0
--- /dev/null
+++ b/backend/payments/src/main/resources/application-local.yml
@@ -0,0 +1,22 @@
+spring:
+  config:
+    activate:
+      on-profile: local
+  r2dbc:
+    url: ${PAYMENTS_R2DBC_URL}
+    username: ${PAYMENTS_DB_USER}
+    password: ${PAYMENTS_DB_PASSWORD}
+  flyway:
+    enabled: true
+    url: ${PAYMENTS_JDBC_URL:${PAYMENTS_DATABASE_URL}}
+    user: ${PAYMENTS_DB_USER}
+    password: ${PAYMENTS_DB_PASSWORD}
+    default-schema: payments
+    locations: classpath:db/migration
+  rabbitmq:
+    uri: ${PAYMENTS_RABBITMQ_URL}
+
+logging:
+  level:
+    root: INFO
+    com.crm.payments: DEBUG
diff --git a/backend/payments/src/main/resources/application.yml b/backend/payments/src/main/resources/application.yml
new file mode 100644
index 0000000000000000000000000000000000000000..52a6ba4df078f35251185477598ecbc74553fc41
--- /dev/null
+++ b/backend/payments/src/main/resources/application.yml
@@ -0,0 +1,33 @@
+spring:
+  application:
+    name: payments-service
+  main:
+    web-application-type: reactive
+  cloud:
+    function:
+      definition: paymentEventsConsumer
+    stream:
+      defaultBinder: rabbit
+      bindings:
+        paymentEventsConsumer-in-0:
+          destination: payments.events
+          group: payments-service
+          contentType: application/json
+        paymentEvents-out-0:
+          destination: payments.events
+          contentType: application/json
+      rabbit:
+        bindings:
+          paymentEventsConsumer-in-0:
+            consumer:
+              autoBindDlq: true
+              deadLetterQueueName: payments.events.dlq
+              republishToDlq: true
+server:
+  port: ${PAYMENTS_SERVICE_PORT:8083}
+
+management:
+  endpoints:
+    web:
+      exposure:
+        include: "health,info"
diff --git a/docs/local-setup.md b/docs/local-setup.md
index 92e4afa2ca19ce616c96695d1202fadf7864c379..7da17a39bafeb43d62a968231cb5f618688033da 100644
--- a/docs/local-setup.md
+++ b/docs/local-setup.md
@@ -206,65 +206,66 @@ docker compose --profile app up -d frontend
 ./scripts/load-seeds.sh
 ```
 
 Скрипт применяет SQL-файлы в порядке Auth → CRM → Payments, выводит прогресс и завершает работу при первой ошибке. Если нужно загрузить только часть набора (например, повторно применить `payments`), воспользуйтесь фильтром по подстроке имени файла:
 
 ```bash
 ./scripts/load-seeds.sh --only payments
 ```
 
 В отсутствии локального `psql` сценарий автоматически выполнит `docker compose exec postgres psql`, перенаправив SQL внутрь контейнера. После успешного завершения появится сообщение `Готово.` — база содержит актуальные тестовые данные для smoke-проверок.
 
 ## 3. Проверьте создание схем и ролей PostgreSQL
 
 Скрипт `infra/postgres/init.sh` автоматически создаёт схемы и роли, указанные в `.env`. Чтобы убедиться, что всё применилось:
 
 ```bash
 docker compose exec postgres psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "\dn"
 ```
 
 В выводе должны присутствовать схемы `auth`, `crm`, `payments`, `documents`, `tasks`, `notifications`, `audit`, `backup`.
 
 ## 4. Запуск миграций
 
 После подготовки инфраструктуры примените миграции сервисов согласно их README. Для CRM/Deals baseline (`2024031501_baseline.py`) уже опубликован, поэтому выполните `poetry run alembic upgrade head` в директории `backend/crm`. Остальные сервисы подключаются по мере появления ревизий.
 
-#### Быстрый запуск миграций (CRM + Auth)
+#### Быстрый запуск миграций (CRM + Auth + Payments)
 
 Чтобы не переключаться вручную между проектами, используйте скрипт из корня репозитория:
 
 ```bash
 ./scripts/migrate-local.sh
 ```
 
 Сценарий:
 
-1. Загружает переменные из `.env` (убедитесь, что он создан на основе `env.example` и содержит заполненные блоки `CRM_*`, `AUTH_*`, `POSTGRES_*`, `REDIS_*`, `RABBITMQ_*`).
+1. Загружает переменные из `.env` (убедитесь, что он создан на основе `env.example` и содержит заполненные блоки `CRM_*`, `AUTH_*`, `PAYMENTS_*`, `POSTGRES_*`, `REDIS_*`, `RABBITMQ_*`).
 2. Запускает `poetry run alembic upgrade head` в `backend/crm`.
 3. Выполняет `./gradlew update` в `backend/auth`.
+4. Выполняет `./gradlew flywayMigrate -PspringProfile=local` в `backend/payments`.
 
-> Требования: установленный Poetry (для CRM) и JDK 17 + Gradle wrapper (для Auth). Перед запуском убедитесь, что PostgreSQL и Redis доступны, а схемы созданы по шагам выше.
+> Требования: установленный Poetry (для CRM) и JDK 17 + Gradle wrapper (для Auth и Payments). Перед запуском убедитесь, что PostgreSQL и Redis доступны, а схемы созданы по шагам выше.
 
 ## 5. Проверка доступности сервисов
 
 ### Основной сценарий: Docker Compose + smoke-check
 
 После `docker compose up -d` (см. шаги bootstrap-скрипта) выполните `./scripts/check-local-infra.sh`, чтобы убедиться в готовности PostgreSQL, Redis, Consul и RabbitMQ Management UI.
 
 - Скрипт ориентирован на тот же набор зависимостей, что и `./scripts/bootstrap-local.sh`: Docker Engine с Compose V2, `psql`, `redis-cli`, `curl` и актуальный `.env`, синхронизированный через [`scripts/sync-env.sh`](../scripts/sync-env.sh). Эти требования уже отражены в [`README.md`](../README.md) и проверяются в первом шаге bootstrap.
 - При наличии Docker Compose проверки выполняются внутри контейнеров (`docker compose exec`) и завершаются ошибкой, если какие-то сервисы не запущены. Сообщение подскажет, какие контейнеры нужно поднять повторно.
 - Результат выводится в виде таблицы. Статус `OK` подтверждает успешный `SELECT 1` в PostgreSQL, `PING → PONG` в Redis, наличие лидера Consul и доступность RabbitMQ UI.
 
 Пример запуска:
 
 ```bash
 ./scripts/check-local-infra.sh
 ```
 
 ### Ручные проверки (fallback)
 ### Автоматизированный smoke-check
 
 1. Убедитесь, что в корне репозитория лежит актуальный `.env` (обновлён через `./scripts/sync-env.sh`, при необходимости с флагом `--non-interactive`).
 2. Проверьте установку утилит, которые использует скрипт:
    - `psql` (PostgreSQL client);
    - `redis-cli`;
    - `curl`.
@@ -301,50 +302,59 @@ docker compose exec postgres psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "\dn"
 - Backend сервисы используют URI `*_DATABASE_URL`, `RABBITMQ_URL`, `REDIS_*`, `CONSUL_HTTP_ADDR`.
 - Фронтенд считывает публичные переменные `NEXT_PUBLIC_*`.
   - Для локального запуска все `NEXT_PUBLIC_*_SSE_URL` и `NEXT_PUBLIC_API_BASE_URL` уже указывают на `http://localhost:${GATEWAY_SERVICE_PORT}`;
     дополнительных DNS-записей или кастомных доменов не требуется.
 - Для фоновых заданий и уведомлений используйте очереди RabbitMQ и Redis из запущенного Docker Compose.
 - Для проверки готовности можно запустить ключевые сервисы локально:
   - **Gateway / BFF:**
 
     ```bash
     cd backend/gateway
     pnpm install
     pnpm start:dev
     ```
 
     После старта убедитесь, что `GET http://localhost:${GATEWAY_SERVICE_PORT}/api/v1/health` возвращает `200 OK`.
 
   - **Auth:**
 
     ```bash
     cd backend/auth
     ./gradlew bootRun
     ```
 
     Перед запуском проверьте, что скопировали свежие значения `AUTH_*` из `env.example` в локальный `.env` (после изменений JWT-параметров вроде `AUTH_JWT_SECRET`, `AUTH_JWT_AUDIENCE`, `AUTH_ACCESS_TOKEN_TTL`, `AUTH_REFRESH_TOKEN_TTL` не забудьте пересоздать `.env`, чтобы подтянуть актуальные настройки). Для проверки доступности сервиса выполните `GET http://localhost:${AUTH_SERVICE_PORT}/actuator/health` — ответ должен быть `200 OK`.
 
+  - **Payments:**
+
+    ```bash
+    cd backend/payments
+    ./gradlew bootRun -PspringProfile=local
+    ```
+
+    Сервис ожидает параметры `PAYMENTS_R2DBC_URL`, `PAYMENTS_JDBC_URL` и `PAYMENTS_RABBITMQ_URL` из `.env`. После старта проверьте `GET http://localhost:${PAYMENTS_SERVICE_PORT}/actuator/health` и SSE-канал `GET http://localhost:${PAYMENTS_SERVICE_PORT}/streams/payments` — оба должны возвращать статус `200 OK`.
+
   - **CRM / Deals:**
 
     ```bash
     cd backend/crm
     poetry install
     poetry run crm-api
     ```
 
     При необходимости поднимите Celery-воркер: `poetry run crm-worker worker -l info`.
 
   - **Frontend:**
 
     ```bash
     cd frontend
     pnpm install
     pnpm dev
     ```
 
     Приложение будет доступно на `http://localhost:${FRONTEND_SERVICE_PORT:-3000}`. Перед запуском можно задать `FRONTEND_SERVICE_PORT=3100` (или `PORT=3100`), чтобы запустить Next.js на другом порту; скрипты `pnpm dev` и `pnpm start` автоматически используют это значение.
 
 ## 7. Очистка состояния
 
 Если нужно полностью пересоздать окружение (например, после изменений схем):
 
 ```bash
diff --git a/docs/tech-stack.md b/docs/tech-stack.md
index de1bd20622bcb7ae1090941a7a6ee9774a1d4443..fb026376cc755481ba73aba14d18fa6826c3c4d6 100644
--- a/docs/tech-stack.md
+++ b/docs/tech-stack.md
@@ -189,63 +189,63 @@ CRM / Deals
 
 API: REST + SSE (через `sse-starlette` для стриминга событий сделок)
 
 Зависимости:
 
 PostgreSQL-схема crm
 
 Redis (очередь Celery)
 
 Использует общий кластер Redis, описанный в разделе «Брокеры сообщений и кэши», и разделяет мониторинг очередей Celery с Notifications.
 
 RabbitMQ выступает шиной доменных событий: сервис подписывается на exchange `payments.events`, читая сообщения через выделенную очередь `crm.payments-sync` с ключами `payments.*`. Для публикации собственных событий (`deal.created`, `deal.updated`, `task.assigned`, документы; SLA-события добавятся после Этапа 1.1) используется отдельный exchange `crm.events`, привязанный к очередям Notifications и Tasks (см. [архитектуру, раздел 2.2](architecture.md#22-асинхронная-шина-rabbitmq)). Подключение реализовано поверх `aio-pika` с подтверждением доставки (publisher confirms) и ручным ack со стороны консьюмера.
 
 Повторные попытки организованы через пару `crm.payments-sync.retry`/`crm.payments-sync.dlx`: основная очередь настроена на dead-letter при ошибках обработки, сообщения попадают в retry-очередь с TTL (60 секунд по умолчанию) и возвращаются в рабочую очередь ограниченное число раз. Невосстановимые сообщения сохраняются в `crm.payments-sync.dlx` для ручного анализа и корреляции с Audit.
 
 Интеграция с Documents-сервисом: загрузки и скачивания проходят через его API, который создаёт и управляет файлами в Google Drive; в PostgreSQL CRM хранит только метаданные (ID, ссылки, привязку к сущностям).
 
 Тестирование и деплой:
 
 Pytest + async-интеграции
 
 Alembic миграции, прогрев кеша
 
 Payments
 
-Язык: Kotlin (JVM 17)
+Язык: Java (JDK 17)
 
-Фреймворк: Spring Boot (WebFlux + Spring Cloud Stream)
+Фреймворк: Spring Boot WebFlux + Spring Cloud Stream (RabbitMQ binder)
 
-БД и очереди: Spring Data R2DBC (PostgreSQL), Spring AMQP (RabbitMQ)
+БД и очереди: Spring Data R2DBC (PostgreSQL), Flyway, StreamBridge + RabbitMQ
 
-API: REST, публикация событий в RabbitMQ
+API: REST (JSON) + SSE (`/streams/payments`), публикация и обработка событий `payments.events`
 
 Зависимости:
 
-PostgreSQL-схема payments
+PostgreSQL-схема payments (таблицы `payments`, `payment_history`, `payment_schedules` + справочники статусов/типов)
 
-RabbitMQ exchange payments.events с маршрутизацией по ключам операций (создание, изменение статусов, возвраты)
+RabbitMQ exchange `payments.events` с обработкой входящих статусов и генерацией собственных событий
 
 Внутренние справочники тарифов CRM с фиксированной валютой учёта RUB без дополнительных пересчётов
 
 Особенности работы
 ------------------
 
 * Все расчёты ведутся в базовой валюте CRM (RUB) без интеграции с внешними сервисами конвертации.
 * Gateway предоставляет REST-эндпоинты Payments только для внутренних клиентов (`/api/v1/payments/**`).
 
 Обмен событиями:
 
 * сервис создаёт сообщения в формате CloudEvents и публикует их в exchange payments.events через Spring AMQP с подтверждением доставки (publisher confirms);
 * Notifications, CRM/Deals и Tasks потребляют события через подписки на очереди с собственными routing key и поддержкой повторных попыток через dead-letter;
 * Audit фиксирует критичные события из отдельной очереди с выдержанным SLA на доставку.
 
 Тестирование и деплой:
 
 JUnit5 + Testcontainers для PostgreSQL и RabbitMQ
 
 Миграции Flyway выполняются из Spring Boot при старте и в CI/CD; конфигурация exchange, очередей и биндингов описана декларативно через Spring AMQP (RabbitAdmin) и применяется вместе с релизом; поэтапный rolling update
 
 Documents
 
 Язык: TypeScript (Node.js)
 
diff --git a/env.example b/env.example
index 0abc4bbec3ee4ddcfea13aaa84ba5a902b94087f..ce355519a51679333659462aaf027d2250dd858d 100644
--- a/env.example
+++ b/env.example
@@ -41,50 +41,52 @@ RABBITMQ_DEFAULT_VHOST=crm
 # правды для пользователей и vhost-ов. При добавлении сервисов обновляйте список
 # переменных ниже — скрипт автоматически создаст соответствующие объекты.
 # Значения выше соответствуют дефолтному пользователю/vhost `crm`, который создаётся Docker Compose.
 # Для сервисов с собственными правами указывайте URL вида `SERVICE_RABBITMQ_URL=amqp://user:pass@host:port/vhost` (см. примеры ниже).
 
 REDIS_HOST=localhost
 REDIS_PORT=6379
 
 CONSUL_HTTP_PORT=8500
 CONSUL_GRPC_PORT=8502
 CONSUL_DNS_PORT=8600
 
 PGADMIN_PORT=5050
 PGADMIN_DEFAULT_EMAIL=admin@local
 PGADMIN_DEFAULT_PASSWORD=admin
 
 # --- URL подключения приложений ---
 # PostgreSQL (единый кластер, отдельные схемы на сервис)
 # См. docs/tech-stack.md → «Инфраструктура» → «Базы данных»
 # Используйте DATABASE_URL для административных задач (миграции, bootstrap данных)
 DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}
 # Auth работает через R2DBC и указывает схему `auth` параметром `schema` (допустим `search_path`)
 AUTH_DATABASE_URL=r2dbc:postgresql://${AUTH_DB_USER}:${AUTH_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?schema=auth
 CRM_DATABASE_URL=postgresql://${CRM_DB_USER}:${CRM_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?search_path=crm
 PAYMENTS_DATABASE_URL=postgresql://${PAYMENTS_DB_USER}:${PAYMENTS_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?search_path=payments
+PAYMENTS_JDBC_URL=jdbc:postgresql://${PAYMENTS_DB_USER}:${PAYMENTS_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?currentSchema=payments
+PAYMENTS_R2DBC_URL=r2dbc:postgresql://${PAYMENTS_DB_USER}:${PAYMENTS_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?schema=payments
 DOCUMENTS_DATABASE_URL=postgresql://${DOCUMENTS_DB_USER}:${DOCUMENTS_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?search_path=documents
 TASKS_DATABASE_URL=postgresql://${TASKS_DB_USER}:${TASKS_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?search_path=tasks
 NOTIFICATIONS_DATABASE_URL=postgresql://${NOTIFICATIONS_DB_USER}:${NOTIFICATIONS_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?search_path=notifications
 AUDIT_DATABASE_URL=postgresql://${AUDIT_DB_USER}:${AUDIT_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?search_path=audit
 BACKUP_DATABASE_URL=postgresql://${BACKUP_DB_USER}:${BACKUP_DB_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?search_path=backup
 
 # Базовый URL использует пользователя CRM и vhost из `${RABBITMQ_DEFAULT_VHOST}`, поэтому подходит сервисам без собственного vhost.
 # Индивидуальные URL ниже требуют, чтобы соответствующие пользователи и vhost-ы были созданы заранее (см. docs/local-setup.md#создайте-пользователей-и-vhost-ы-rabbitmq-для-сервисов).
 RABBITMQ_URL=amqp://${RABBITMQ_DEFAULT_USER}:${RABBITMQ_DEFAULT_PASS}@${RABBITMQ_HOST}:${RABBITMQ_PORT}/${RABBITMQ_DEFAULT_VHOST}
 CRM_RABBITMQ_URL=${RABBITMQ_URL}                            # CRM публикует события во vhost `crm`; переопределите при другом пользователе
 RABBITMQ_MANAGEMENT_URL=http://${RABBITMQ_HOST}:${RABBITMQ_MANAGEMENT_PORT}
 
 # Redis (сессии, кеши, фоновые очереди)
 # См. docs/tech-stack.md → «Инфраструктура» → «Брокеры сообщений и кэши»
 REDIS_URL=redis://${REDIS_HOST}:${REDIS_PORT}/0
 REDIS_CACHE_URL=redis://${REDIS_HOST}:${REDIS_PORT}/1
 REDIS_CELERY_URL=redis://${REDIS_HOST}:${REDIS_PORT}/2
 REDIS_BULLMQ_URL=redis://${REDIS_HOST}:${REDIS_PORT}/3
 REDIS_RATE_LIMIT_URL=redis://${REDIS_HOST}:${REDIS_PORT}/4
 REDIS_KEY_PREFIX=gateway
 REDIS_CACHE_TTL=300
 REDIS_HEARTBEAT_PREFIX=gateway:sse
 
 # Consul (service discovery и конфигурация)
 # См. docs/tech-stack.md → «Инфраструктура» → «Service discovery»
diff --git a/scripts/bootstrap-local.sh b/scripts/bootstrap-local.sh
index 8d3f32400fdfe4df501b72ad5ebc360ed3d3eee7..2c183fe02caee5a959c38399964fb103c404f9d2 100755
--- a/scripts/bootstrap-local.sh
+++ b/scripts/bootstrap-local.sh
@@ -95,56 +95,58 @@ run_step_skip() {
 
 step_check_dependencies() {
   local status=0
   require_command docker || status=1
   if docker compose version >/dev/null 2>&1; then
     :
   else
     log_error "Плагин 'docker compose' недоступен. Установите Docker Compose V2."
     status=1
   fi
   require_command poetry || status=1
   if require_command java "java (JDK 17+)"; then
     :
   else
     status=1
   fi
   if require_command python3 "python3 (Python 3)"; then
     :
   else
     log_error "Python 3 обязателен для bootstrap. Установите интерпретатор python3 из поставки вашей ОС (например, 'sudo apt install python3') и повторите попытку."
     status=1
   fi
   check_optional_command psql "psql" "Отсутствует локальный CLI PostgreSQL — скрипты будут пытаться использовать docker compose exec."
   check_optional_command redis-cli "redis-cli" "Для локальных проверок Redis используйте docker compose exec redis redis-cli."
   check_optional_command curl "curl" "Smoke-проверки HTTP будут пропущены или потребуют альтернативные инструменты."
-  if [[ -x "${ROOT_DIR}/backend/auth/gradlew" ]]; then
-    :
-  else
-    log_warn "Делаем gradlew исполняемым"
+  if [[ ! -x "${ROOT_DIR}/backend/auth/gradlew" ]]; then
+    log_warn "Делаем gradlew исполняемым (auth)"
     chmod +x "${ROOT_DIR}/backend/auth/gradlew"
   fi
+  if [[ ! -x "${ROOT_DIR}/backend/payments/gradlew" ]]; then
+    log_warn "Делаем gradlew исполняемым (payments)"
+    chmod +x "${ROOT_DIR}/backend/payments/gradlew"
+  fi
   return $status
 }
 
 step_sync_env() {
   (cd "${ROOT_DIR}" && ./scripts/sync-env.sh --non-interactive)
 }
 
 step_compose_up() {
   (cd "${INFRA_DIR}" && docker compose up -d)
 }
 
 step_wait_infra() {
   (
     cd "${INFRA_DIR}" || return 1
     if docker compose wait >/dev/null 2>&1; then
       echo "docker compose wait завершён успешно"
       return 0
     fi
 
     echo "Команда 'docker compose wait' недоступна, включён ручной мониторинг статусов"
     local attempt=0
     local max_attempts=30
     local sleep_seconds=2
     local ps_output=""
 
diff --git a/scripts/check-local-infra.sh b/scripts/check-local-infra.sh
index 4f280590b27d247803feeb87492a7619e68dddcf..4af59b161122dd40c465615ee1f65497fb860415 100755
--- a/scripts/check-local-infra.sh
+++ b/scripts/check-local-infra.sh
@@ -211,49 +211,71 @@ function check_rabbitmq() {
       local output
       if output=$(docker_exec rabbitmq rabbitmq-diagnostics -q check_running 2>&1); then
         add_result "$name" "OK" "Нода запущена (rabbitmq-diagnostics)"
       else
         add_result "$name" "FAIL" "$output"
       fi
     fi
     return
   fi
 
   local url_base="${RABBITMQ_MANAGEMENT_URL:-}"
   local user="${RABBITMQ_DEFAULT_USER:-}"
   local pass="${RABBITMQ_DEFAULT_PASS:-}"
   if [[ -z "$url_base" || -z "$user" || -z "$pass" ]]; then
     add_result "$name" "FAIL" "Требуются RABBITMQ_MANAGEMENT_URL, RABBITMQ_DEFAULT_USER, RABBITMQ_DEFAULT_PASS"
     return
   fi
   local output
   if output=$(curl -fsS -u "$user:$pass" "$url_base/api/overview" 2>&1); then
     add_result "$name" "OK" "UI доступен"
   else
     add_result "$name" "FAIL" "$output"
   fi
 }
 
+function check_payments_service() {
+  local name="Payments API"
+  local base="${PAYMENTS_BASE_URL:-http://localhost:${PAYMENTS_SERVICE_PORT:-8083}}"
+  local health_url
+  if [[ -z "$base" ]]; then
+    add_result "$name" "FAIL" "PAYMENTS_BASE_URL не задан в .env"
+    return
+  fi
+  health_url="${base%/}/actuator/health"
+  local output
+  if output=$(curl -fsS "$health_url" 2>&1); then
+    if grep -q '"status"\s*:\s*"UP"' <<<"$output"; then
+      add_result "$name" "OK" "$health_url → UP"
+    else
+      add_result "$name" "FAIL" "Ответ: $output"
+    fi
+  else
+    add_result "$name" "FAIL" "$output"
+  fi
+}
+
 function print_mode_message() {
   if [[ "$CHECK_MODE" == "docker" ]]; then
     return
   fi
   echo "[Инфо] Проверки выполняются локальными CLI-инструментами." >&2
 }
 
 detect_docker_compose
 print_mode_message
 
 check_postgres
 check_redis
 check_consul
 check_rabbitmq
+check_payments_service
 
 printf "\n%-18s | %-6s | %s\n" "Проверка" "Статус" "Комментарий"
 printf '%s\n' "------------------+--------+--------------------------------"
 for entry in "${REPORT[@]}"; do
   IFS='|' read -r name status message <<<"$entry"
   printf "%-18s | %-6s | %s\n" "$name" "$status" "$message"
 
 done
 
 exit $EXIT_CODE
diff --git a/scripts/migrate-local.sh b/scripts/migrate-local.sh
index 0abbde19bef3df2d733280caa3385ad196bd3277..4baa85386278ffd97e23fac22a3c9b73bed65b8c 100755
--- a/scripts/migrate-local.sh
+++ b/scripts/migrate-local.sh
@@ -5,29 +5,37 @@ if [[ ! -f .env ]]; then
   echo "[migrate-local] Файл .env не найден в корне репозитория. Скопируйте env.example и заполните значения." >&2
   exit 1
 fi
 
 # Загружаем переменные окружения из .env
 set -a
 source .env
 set +a
 
 ROOT_DIR=$(pwd)
 
 run_crm_migrations() {
   echo "[migrate-local] Применяем миграции CRM (Alembic)..."
   pushd "$ROOT_DIR/backend/crm" >/dev/null
   poetry run alembic upgrade head
   popd >/dev/null
 }
 
 run_auth_migrations() {
   echo "[migrate-local] Применяем миграции Auth (Liquibase)..."
   pushd "$ROOT_DIR/backend/auth" >/dev/null
   ./gradlew update
   popd >/dev/null
 }
 
+run_payments_migrations() {
+  echo "[migrate-local] Применяем миграции Payments (Flyway)..."
+  pushd "$ROOT_DIR/backend/payments" >/dev/null
+  ./gradlew flywayMigrate -PspringProfile=local
+  popd >/dev/null
+}
+
 run_crm_migrations
 run_auth_migrations
+run_payments_migrations
 
-echo "[migrate-local] Миграции CRM и Auth применены."
+echo "[migrate-local] Миграции CRM, Auth и Payments применены."
